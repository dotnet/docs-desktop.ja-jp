---
title: .NET Core 3.0 への WPF アプリの移行
description: Windows Presentation Foundation (WPF) アプリを .NET Core 3.0 に移行する方法について説明します。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.topic: how-to
ms.openlocfilehash: f9267ca1da922858f8d6acf470bf4831301335fd
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96942370"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="dd092-103">.NET Core への WPF アプリの移行</span><span class="sxs-lookup"><span data-stu-id="dd092-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="dd092-104">この記事では、Windows Presentation Foundation (WPF) アプリを .NET Framework から .NET Core 3.0 に 移行するために必要な手順について説明します。</span><span class="sxs-lookup"><span data-stu-id="dd092-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="dd092-105">移植する WPF アプリが手元になくても、このプロセスを試してみたい場合は、[GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) で入手できる **Bean Trader** サンプル アプリを使用できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="dd092-106">元のアプリ (.NET Framework 4.7.2 をターゲットとする) は、NetFx\BeanTraderClient フォルダーにあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="dd092-107">まず、一般的にアプリの移植に必要な手順について説明し、次に **Bean Trader** サンプルに適用される特定の変更について説明します。</span><span class="sxs-lookup"><span data-stu-id="dd092-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="dd092-108">.NET Core に移行するには、最初に以下を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="dd092-109">NuGet の依存関係を理解し、更新します。</span><span class="sxs-lookup"><span data-stu-id="dd092-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="dd092-110">`<PackageReference>` 形式を使用するように NuGet の依存関係をアップグレードします。</span><span class="sxs-lookup"><span data-stu-id="dd092-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="dd092-111">.NET Core または .NET Standard の互換性に関する最上位の NuGet の依存関係を確認します。</span><span class="sxs-lookup"><span data-stu-id="dd092-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="dd092-112">NuGet パッケージを新しいバージョンにアップグレードします。</span><span class="sxs-lookup"><span data-stu-id="dd092-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="dd092-113">[.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) を使用して、.NET の依存関係を理解します。</span><span class="sxs-lookup"><span data-stu-id="dd092-113">Use the [.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="dd092-114">プロジェクト ファイルを新しい SDK スタイルの形式に移行します。</span><span class="sxs-lookup"><span data-stu-id="dd092-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="dd092-115">.NET Core と .NET Framework の両方をターゲットとするか、.NET Core のみをターゲットとするかを選択します。</span><span class="sxs-lookup"><span data-stu-id="dd092-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="dd092-116">関連するプロジェクト ファイルのプロパティと項目を新しいプロジェクト ファイルにコピーします。</span><span class="sxs-lookup"><span data-stu-id="dd092-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="dd092-117">ビルドの問題を修正します。</span><span class="sxs-lookup"><span data-stu-id="dd092-117">Fix build issues:</span></span>

    01. <span data-ttu-id="dd092-118">[Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) パッケージへの参照を追加します。</span><span class="sxs-lookup"><span data-stu-id="dd092-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="dd092-119">API レベルの相違点を見つけて修正します。</span><span class="sxs-lookup"><span data-stu-id="dd092-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="dd092-120">`appSettings` または `connectionStrings` 以外の *app.config* セクションを削除します。</span><span class="sxs-lookup"><span data-stu-id="dd092-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="dd092-121">必要に応じて、生成されたコードを再生成します。</span><span class="sxs-lookup"><span data-stu-id="dd092-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="dd092-122">ランタイムのテストを行います。</span><span class="sxs-lookup"><span data-stu-id="dd092-122">Runtime testing:</span></span>

    01. <span data-ttu-id="dd092-123">移植されたアプリが想定どおりに動作することを確認します。</span><span class="sxs-lookup"><span data-stu-id="dd092-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="dd092-124"><xref:System.NotSupportedException> 例外に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="dd092-125">サンプルについて</span><span class="sxs-lookup"><span data-stu-id="dd092-125">About the sample</span></span>

<span data-ttu-id="dd092-126">この記事では、[Bean Trader サンプル アプリ](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)を参照しています。これは、実際の WPF アプリのものと類似するさまざまな依存関係がそこで使用されているためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="dd092-127">このアプリは大きくはありませんが、複雑さの点で "Hello World" からのステップアップを意図しています。</span><span class="sxs-lookup"><span data-stu-id="dd092-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="dd092-128">このアプリでは、ユーザーが実際のアプリを移植するときに発生する可能性のある問題が実証されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="dd092-129">このアプリは WCF サービスと通信するので、これを適切に実行するためには、BeanTraderServer プロジェクト (同じ GitHub リポジトリで入手できます) を実行し、BeanTraderClient の構成が正しいエンドポイントを指していることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="dd092-130">(既定では、このサンプルではサーバーが `http://localhost:8090` の同じコンピューターで実行されていることが前提となっています。BeanTraderServer をローカルで起動した場合はこれが該当します。)</span><span class="sxs-lookup"><span data-stu-id="dd092-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="dd092-131">このサンプル アプリは、.NET Core の移植に関する課題と解決策を示すことを目的としている点に留意してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="dd092-132">WPF のベスト プラクティスを示すことを目的としたものではありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="dd092-133">実際、いくつかのアンチパターンが意図的に組み込まれており、移植中に少なくともいくつかの有用な課題が確実に発生するようになっています。</span><span class="sxs-lookup"><span data-stu-id="dd092-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="dd092-134">開発の準備</span><span class="sxs-lookup"><span data-stu-id="dd092-134">Getting ready</span></span>

<span data-ttu-id="dd092-135">.NET Framework アプリを .NET Core に移行する際の主な課題は、その依存関係が異なる動作をする場合やまったく動作しない場合があることです。</span><span class="sxs-lookup"><span data-stu-id="dd092-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="dd092-136">移行は以前よりはるかに簡単になり、多くの NuGet パッケージが .NET Standard をターゲットにするようになっています。</span><span class="sxs-lookup"><span data-stu-id="dd092-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="dd092-137">.NET Core 2.0 以降、.NET Framework と .NET Core の領域が類似するようになっています。</span><span class="sxs-lookup"><span data-stu-id="dd092-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="dd092-138">それでも、相違点は (NuGet パッケージによるサポートと使用可能な .NET API の両方に) いくつか残っています 。</span><span class="sxs-lookup"><span data-stu-id="dd092-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="dd092-139">移行の最初の手順では、アプリの依存関係を確認し、参照が .NET Core に簡単に移行できる形式であることを確かめます。</span><span class="sxs-lookup"><span data-stu-id="dd092-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="dd092-140">`<PackageReference>` NuGet 参照へのアップグレード</span><span class="sxs-lookup"><span data-stu-id="dd092-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="dd092-141">通常、以前の .NET Framework プロジェクトでは、NuGet の依存関係は *packages.config* ファイルにリストされます。</span><span class="sxs-lookup"><span data-stu-id="dd092-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="dd092-142">新しい SDK スタイルのプロジェクト ファイル形式では、別の構成ファイルではなく、csproj ファイル自体の [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) 要素として NuGet パッケージを参照します。</span><span class="sxs-lookup"><span data-stu-id="dd092-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="dd092-143">移行時に `<PackageReference>` スタイルの参照を使用する利点は 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="dd092-144">これは、新しい .NET Core プロジェクト ファイルに必要な NuGet 参照のスタイルです。</span><span class="sxs-lookup"><span data-stu-id="dd092-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="dd092-145">既に `<PackageReference>` を使用している場合、これらのプロジェクト ファイルの要素をコピーして、直接新しいプロジェクトに貼り付けることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="dd092-146">packages.config ファイルとは異なり、`<PackageReference>` 要素は、プロジェクトが直接依存する最上位の依存関係のみを参照します。</span><span class="sxs-lookup"><span data-stu-id="dd092-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="dd092-147">他のすべての推移的な NuGet パッケージは復元時に判別され、自動生成された obj\project.assets.json ファイルに記録されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="dd092-148">これにより、プロジェクトにどのような依存関係があるかを判断するのがはるかに簡単になり、必要な依存関係が .NET Core で動作するかどうかを判断するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dd092-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="dd092-149">.NET Framework アプリを .NET Core に移行する最初の手順は、それを、`<PackageReference>` NuGet 参照を使用するように更新することです。</span><span class="sxs-lookup"><span data-stu-id="dd092-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="dd092-150">Visual Studio を使用すると、これを簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="dd092-151">Visual Studio の **ソリューション エクスプローラー** で プロジェクトの *packages.config* ファイルを右クリックし、次に **[packages.config を PackageReference に移行する]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="dd092-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![PackageReference へのアップグレード](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="dd092-153">計算された最上位の NuGet 依存関係を表示し、他のどの NuGet パッケージを最上位に昇格する必要があるかを尋ねるダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="dd092-154">Bean Trader サンプルでは、これらの他のパッケージはいずれも最上位にする必要はないため、それらのボックスをすべてオフにすることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="dd092-155">次に、 **[OK]** をクリックすると、*packages.config* ファイルが削除され、`<PackageReference>` 要素がプロジェクト ファイルに追加されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="dd092-156">`<PackageReference>` スタイルの参照では、NuGet パッケージはパッケージ フォルダーにローカルに格納されません。</span><span class="sxs-lookup"><span data-stu-id="dd092-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="dd092-157">代わりに、最適化としてグローバルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="dd092-158">移行が完了したら、csproj ファイルを編集し、以前に *..\packages* ディレクトリから取得したアナライザーを参照するすべての `<Analyzer>` 要素を削除します。</span><span class="sxs-lookup"><span data-stu-id="dd092-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="dd092-159">ご心配は不要です。NuGet パッケージ参照は維持されるため、アナライザーはプロジェクトに含まれます。</span><span class="sxs-lookup"><span data-stu-id="dd092-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="dd092-160">必要なことは、以前の packages.config スタイルの `<Analyzer>` 要素をクリーンアップするだけです。</span><span class="sxs-lookup"><span data-stu-id="dd092-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="dd092-161">NuGet パッケージの確認</span><span class="sxs-lookup"><span data-stu-id="dd092-161">Review NuGet packages</span></span>

<span data-ttu-id="dd092-162">プロジェクトが依存する最上位の NuGet パッケージが表示されるようになったので、それらのパッケージを .NET Core で使用できるかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="dd092-163">パッケージが .NET Core をサポートしているかどうかは、[nuget.org](https://www.nuget.org/) でその依存関係を調べることで判断できます。コミュニティによって作成された [fuget.org](https://www.fuget.org/) サイトでは、この情報がパッケージ情報ページの上部に目立つように表示されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="dd092-164">.Net Core 3.0 をターゲットとする場合、.NET Core または .NET Standard をターゲットとするパッケージはすべて動作するはずです (.NET Core では .NET Standard の領域が実装されるため)。</span><span class="sxs-lookup"><span data-stu-id="dd092-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="dd092-165">場合によっては、使用されているパッケージの特定のバージョンで .NET Core または .NET Standard がターゲットにならないことがありますが、新しいバージョンではターゲットになります。</span><span class="sxs-lookup"><span data-stu-id="dd092-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="dd092-166">この場合は、最新バージョンのパッケージにアップグレードすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="dd092-167">.NET Framework をターゲットとするパッケージも使用できますが、それにはある程度のリスクが伴います。</span><span class="sxs-lookup"><span data-stu-id="dd092-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="dd092-168">.NET Core から .NET Framework への依存関係は許容されます。 .NET Core と .NET Framework の領域は類似しているので、このような依存関係は "*多くの場合*" 機能するためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="dd092-169">ただし、パッケージで .NET Core に存在しない .NET API を使用しようとすると、ランタイム例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="dd092-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="dd092-170">そのため、選択可能なオプションが他にない場合にのみ .NET Framework パッケージを参照し、これを行うことによってテストの負担が生じることを理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="dd092-171">.NET Core や .NET Standard をターゲットとしないパッケージが参照されている場合は、他の代替手段を検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="dd092-172">代わりに使用できる類似のパッケージは他にあるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="dd092-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="dd092-173">NuGet の作成者が、特に .NET Core をターゲットとする別個の '.Core' バージョンのライブラリを公開している場合があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="dd092-174">Enterprise Library パッケージは、コミュニティ発行 ".NetCore" の代替手段の例です。</span><span class="sxs-lookup"><span data-stu-id="dd092-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="dd092-175">他のケースとして、特定のサービス用の新しい SDK が (ときにより、異なるパッケージ名で) .NET Standard 用に用意されています。</span><span class="sxs-lookup"><span data-stu-id="dd092-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="dd092-176">使用できる他の代替手段がない場合は、.NET Framework をターゲットとするパッケージを使用して続行できますが、.NET Core で実行する際は、十分なテストが必要になることを念頭に置いてください。</span><span class="sxs-lookup"><span data-stu-id="dd092-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="dd092-177">Bean Trader サンプルには、次の最上位 NuGet 依存関係があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="dd092-178">**Castle.Windsor、バージョン 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="dd092-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="dd092-179">このパッケージは .NET Standard 1.6 をターゲットとしているため、.NET Core で動作します。</span><span class="sxs-lookup"><span data-stu-id="dd092-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="dd092-180">**Microsoft.CodeAnalysis.FxCopAnalyzers、バージョン 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="dd092-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="dd092-181">これはメタパッケージであるため、 どのプラットフォームがサポートされるかはすぐには明らかになりません。ただし、[ドキュメント](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)には、その最新バージョン (2.9.2) が .NET Framework と .NET Core の両方で動作することが示されています。</span><span class="sxs-lookup"><span data-stu-id="dd092-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="dd092-182">**Nito.AsyncEx、バージョン 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="dd092-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="dd092-183">このパッケージは .NET Core をターゲットとしていませんが、新しい 5.0 バージョンではターゲットとしています。</span><span class="sxs-lookup"><span data-stu-id="dd092-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="dd092-184">これは移行時によくあることです。多くの NuGet パッケージでは .NET Standard のサポートが最近追加されていますが、以前のバージョンのプロジェクトでは .NET Framework のみがターゲットになるためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="dd092-185">バージョンの違いがマイナー バージョンの違いであれば、多くの場合、新しいバージョンに簡単にアップグレードできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="dd092-186">これはメジャー バージョンの変更であるため、パッケージに破壊的変更が生じる可能性があるので、アップグレード時には注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="dd092-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="dd092-187">しかし、前進できるので、それは望ましいことです。</span><span class="sxs-lookup"><span data-stu-id="dd092-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="dd092-188">**MahApps.Metro、バージョン1.6.5**</span><span class="sxs-lookup"><span data-stu-id="dd092-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="dd092-189">このパッケージも .NET Core をターゲットとしていませんが、これをターゲットとする新しいプレリリース (2.0 アルファ版) があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="dd092-190">この場合も、破壊的変更について注意する必要がありますが、新しいパッケージがあることは心強いものです。</span><span class="sxs-lookup"><span data-stu-id="dd092-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="dd092-191">Bean Trader サンプルの NuGet の依存関係はすべて .NET Standard または .NET Core をターゲットとしているか、これらをターゲットとする新しいバージョンを備えています。そのため、ここで障害となる問題が生じる可能性はほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="dd092-192">NuGet パッケージのアップグレード</span><span class="sxs-lookup"><span data-stu-id="dd092-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="dd092-193">可能であれば、破壊的変更を早期に検出して対処するために、この時点 (プロジェクトが引き続き .NET Framework をターゲットとしている状態) で、.NET Core または .NET Standard のみをターゲットとするパッケージのバージョンをより新しいバージョンにアップグレードすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dd092-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="dd092-194">アプリの既存の .NET Framework バージョンに対して重大な変更を加えたくない場合は、.NET Core をターゲットとする新しいプロジェクト ファイルが作成されるまで待つことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="dd092-195">ただし、NuGet パッケージを前もって .NET Core の互換バージョンにアップグレードしておくと、新しいプロジェクト ファイルを作成したときの移行プロセスがより簡単になり、アプリの .NET Framework と .NET Core のバージョンの相違点が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="dd092-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="dd092-196">Bean Trader サンプルを使用すると、(Visual Studio の NuGet パッケージ マネージャーを使用して) 必要なすべてのアップグレードを簡単に行うことができますが、1 つ例外があります。**MahApps.Metro 1.6.5** から **2.0** にアップグレードすると、テーマとアクセント管理の API に関する破壊的変更が発生します。</span><span class="sxs-lookup"><span data-stu-id="dd092-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="dd092-197">可能であれば、新しいバージョンのパッケージを使用するようにアプリを更新してください (その方が .NET Core で動作する可能性が高いためです)。</span><span class="sxs-lookup"><span data-stu-id="dd092-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="dd092-198">ただし、これが可能でない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="dd092-199">このような場合は、**MahApps.Metro** をアップグレードしないでください。必要な変更が簡単ではないことと、このチュートリアルでは **MahApps.Metro 2** ではなく .NET Core 3 への移行に焦点を置いているからです。</span><span class="sxs-lookup"><span data-stu-id="dd092-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="dd092-200">また、Bean Trader アプリでは **MahApps.Metro** のわずかな部分のみが実行されるため、これはリスクの低い .NET Framework 依存関係です。</span><span class="sxs-lookup"><span data-stu-id="dd092-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="dd092-201">もちろん、移行が完了したら、すべてが正常に機能していることを確認するためのテストが必要になります。</span><span class="sxs-lookup"><span data-stu-id="dd092-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="dd092-202">これが実際のシナリオである場合は、**MahApps.Metro** バージョン 2.0 に移行する作業を追跡するために課題を提起することをお勧めします。移行を行わないと、今度は、技術的な問題点が残ったままになるためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="dd092-203">NuGet パッケージが最新バージョンに更新されると、Bean Trader サンプルのプロジェクト ファイル内の `<PackageReference>` 項目グループは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="dd092-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="dd092-204">.NET Framework の移植性の分析</span><span class="sxs-lookup"><span data-stu-id="dd092-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="dd092-205">プロジェクトの NuGet 依存関係の状態を把握したら、次に考慮すべき点は、.NET Framework API の依存関係です。</span><span class="sxs-lookup"><span data-stu-id="dd092-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="dd092-206">[.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) ツールは、プロジェクトで使用されている .NET API のうち、他の .NET プラットフォームで利用可能なものを理解するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dd092-206">The [.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="dd092-207">このツールは、[Visual Studio プラグイン](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)や[コマンドライン ツール](https://github.com/Microsoft/dotnet-apiport/releases)として提供されるか、オプションを単純化する[シンプルな GUI](https://github.com/Microsoft/dotnet-apiport-ui) 内にラップされています。</span><span class="sxs-lookup"><span data-stu-id="dd092-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="dd092-208">GUI を使用した .NET Portability Analyzer (API Port) の使用の詳細については、「[.NET Core へのデスクトップ アプリの移植](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)」というブログ記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="dd092-209">コマンド ラインを使用する場合に必要な手順は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="dd092-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="dd092-210">[.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) がまだない場合は、ダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="dd092-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="dd092-211">移植する .NET Framework アプリが正常にビルドされていることを確認します (移行前に必ずこれを行うことをお勧めします)。</span><span class="sxs-lookup"><span data-stu-id="dd092-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="dd092-212">次のようなコマンド ラインを使用して API Port を実行します。</span><span class="sxs-lookup"><span data-stu-id="dd092-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="dd092-213">`-f` 引数は、分析するバイナリを含むパスを指定します。</span><span class="sxs-lookup"><span data-stu-id="dd092-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="dd092-214">`-r` 引数は、使用する出力ファイル形式を指定します。</span><span class="sxs-lookup"><span data-stu-id="dd092-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="dd092-215">`-t` 引数は、API の使用状況の分析対象である .NET プラットフォームを指定します。</span><span class="sxs-lookup"><span data-stu-id="dd092-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="dd092-216">この場合は .NET Core です。</span><span class="sxs-lookup"><span data-stu-id="dd092-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="dd092-217">HTML レポートを開くと、最初のセクションに、分析されたすべてのバイナリと、それらで使用される .NET API のうち何パーセントをターゲット プラットフォームで使用できるかが一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="dd092-218">このパーセントは、それ自体では意味がありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="dd092-219">さらに役に立つのは、欠落している特定の API を確認することです。</span><span class="sxs-lookup"><span data-stu-id="dd092-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="dd092-220">これを行うには、アセンブリ名を選択するか、個々のアセンブリのレポートまで下にスクロールします。</span><span class="sxs-lookup"><span data-stu-id="dd092-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="dd092-221">ご自身がソース コードを所有しているアセンブリに注目してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="dd092-222">たとえば、Bean Trader ApiPort レポートには多くのバイナリが一覧表示されますが、そのほとんどは NuGet パッケージに属しています。</span><span class="sxs-lookup"><span data-stu-id="dd092-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="dd092-223">`Castle.Windsor` は、.NET Core に存在しないいくつかの System.Web API に依存していることを示しています。</span><span class="sxs-lookup"><span data-stu-id="dd092-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="dd092-224">.NET Core が `Castle.Windsor` によってサポートされていることを事前に確認しているため、これは問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="dd092-225">一般に、NuGet パッケージにはさまざまな .NET プラットフォームで使用する各種のバイナリがあるため、`Castle.Windsor` の .NET Framework バージョンで System.Web API が使用されるかどうかは、パッケージが、(この API が使用される) .NET Standard または .NET Core もターゲットとしている限り、重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="dd092-226">Bean Trader サンプルでは、考慮する必要があるバイナリは **BeanTraderClient** のみであり、レポートでは、`System.ServiceModel.ClientBase<T>.Close` と `System.ServiceModel.ClientBase<T>.Open` の 2 つの .NET API だけが欠落していることが示されています。</span><span class="sxs-lookup"><span data-stu-id="dd092-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient の移植性レポート](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="dd092-228">これらが障害となる問題になる可能性はほとんどありません。WCF クライアント API は (ほとんどの場合) .NET Core でサポートされるので、これらの主要 API には代替手段が用意されているはずであるためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="dd092-229">事実、(<https://apisof.net> を使用して) `System.ServiceModel` の .NET Core の領域を調べると、.NET Core では代わりに非同期の代替手段があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="dd092-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="dd092-230">このレポートと以前の NuGet 依存関係分析に基づいて、Bean Trader サンプルを .NET Core に移行する際に大きな問題はないと考えられます。</span><span class="sxs-lookup"><span data-stu-id="dd092-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="dd092-231">これで、実際に移行を開始する次の手順の準備が整いました。</span><span class="sxs-lookup"><span data-stu-id="dd092-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="dd092-232">プロジェクト ファイルの移行</span><span class="sxs-lookup"><span data-stu-id="dd092-232">Migrating the project file</span></span>

<span data-ttu-id="dd092-233">お使いのアプリで新しい [SDK スタイルのプロジェクト ファイル形式](/dotnet/core/tools/csproj)を使用していない場合は、.NET Core をターゲットとする新しいプロジェクト ファイルが必要になります。</span><span class="sxs-lookup"><span data-stu-id="dd092-233">If your app isn't using the new [SDK-style project file format](/dotnet/core/tools/csproj), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="dd092-234">既存の csproj ファイルを置き換えることも、既存のプロジェクトを現在の状態に維持する場合は、.NET Core をターゲットとする新しい csproj ファイルを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="dd092-235">[マルチターゲット](/dotnet/standard/library-guidance/cross-platform-targeting) (複数の `<TargetFrameworks>` ターゲットを指定すること) を使用すると、1 つの SDK スタイル プロジェクト ファイルで .NET Framework 用と .NET Core 用のアプリのバージョンをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](/dotnet/standard/library-guidance/cross-platform-targeting) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="dd092-236">新しいプロジェクト ファイルを作成する場合、Visual Studio で新しい WPF プロジェクトを作成することも、一時ディレクトリで `dotnet new wpf` コマンドを使用してプロジェクト ファイルを生成してから、それを適切な場所にコピー/名前変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="dd092-237">また、コミュニティによって作成されたツール [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) もあります。これを使用すると、プロジェクト ファイルの移行の一部を自動化できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="dd092-238">このツールは便利ですが、それでも移行のすべての詳細が正しいことを確認するために、人間が結果をレビューする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="dd092-239">このツールで適切に処理できない特定の分野の 1 つは、*packages.config* ファイルからの NuGet パッケージの移行です。</span><span class="sxs-lookup"><span data-stu-id="dd092-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="dd092-240">NuGet パッケージを参照するためにまだ *packages.config* ファイルを使用しているプロジェクト ファイルでこのツールを実行すると、自動的に `<PackageReference>` 要素に移行されますが、最上位のパッケージだけでなく、"*すべての*" パッケージに対して `<PackageReference>` 要素が追加されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="dd092-241">(このサンプルで行ったように) Visual Studio を使用して `<PackageReference>` 要素に既に移行している場合は、変換の残りの部分でこのツールが役立します。</span><span class="sxs-lookup"><span data-stu-id="dd092-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="dd092-242">Scott Hanselman 氏が [csproj ファイルの移行に関する彼のブログ記事](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)で勧めているように、手操作で移植すると、そこから学ぶことができ、移植するプロジェクトが少数のみである場合は、より良い結果が得られます。</span><span class="sxs-lookup"><span data-stu-id="dd092-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="dd092-243">しかし、数十や数百ものプロジェクト ファイルを移植する場合は、[[CsprojToVs2017]](https://github.com/hvanbakel/CsprojToVs2017) などのツールが役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="dd092-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="dd092-244">Bean Trader サンプル用に新しいプロジェクト ファイルを作成するには、一時ディレクトリで `dotnet new wpf` を実行し、生成された *.csproj* ファイルを *BeanTraderClient* フォルダーに移動して、その名前を **BeanTraderClient.Core.csproj** に変更します。</span><span class="sxs-lookup"><span data-stu-id="dd092-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="dd092-245">新しいプロジェクト ファイル形式には、そのディレクトリの中または下で見つかる C# ファイル、*resx* ファイル、XAML ファイルが自動的に含まれるため、プロジェクト ファイルは既にほぼ完成しています。</span><span class="sxs-lookup"><span data-stu-id="dd092-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="dd092-246">移行を完了するには、以前のプロジェクト ファイルと新しいプロジェクト ファイルを横に並べて開き、以前のプロジェクト ファイルを調べて、そこに含まれる情報に移行が必要なものがあるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="dd092-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="dd092-247">Bean Trader サンプルの場合、次の項目を新しいプロジェクトにコピーする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="dd092-248">`<RootNamespace>`、`<AssemblyName>`、`<ApplicationIcon>` プロパティをすべてコピーする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="dd092-249">また、`<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` プロパティも新しいプロジェクト ファイルに追加する必要があります。Bean Trader サンプルでは、AssemblyInfo.cs ファイルにアセンブリ レベルの属性 (`[AssemblyTitle]` など) が含まれているためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="dd092-250">既定では、新しい SDK スタイルのプロジェクトにより、csproj ファイルのプロパティに基づいてこれらの属性が自動生成されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="dd092-251">ここでは、これが行われないようにしたいので (自動生成された属性は AssemblyInfo.cs のものと競合します)、`<GenerateAssemblyInfo>` を使用して自動生成される属性を無効にします。</span><span class="sxs-lookup"><span data-stu-id="dd092-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="dd092-252">*resx* ファイルは埋め込みリソースとして自動的に含まれますが、イメージなどの他の `<Resource>` 項目は含まれません。</span><span class="sxs-lookup"><span data-stu-id="dd092-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="dd092-253">そのため、イメージとアイコンのファイルを埋め込むには `<Resource>` 要素をコピーしてください。</span><span class="sxs-lookup"><span data-stu-id="dd092-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="dd092-254">新しいプロジェクト ファイル形式での glob パターン (`<Resource Include="**\*.png" />`) のサポートを利用すると、png 参照を 1 行に簡略化できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="dd092-255">同様に、`<None>` 項目は自動的に含まれますが、既定では出力ディレクトリにコピーされません。</span><span class="sxs-lookup"><span data-stu-id="dd092-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="dd092-256">Bean Trader プロジェクトには、(`PreserveNewest` の動作を使用して) 出力ディレクトリにコピー "*される*" `<None>` 項目が含まれているので、次のように、そのファイルに対して自動的に設定される `<None>` 項目を更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="dd092-257">Bean Trader サンプルには、XAML ファイル (Default.Accent.xaml) が (`Page` ではなく) `Content` として含まれます。このファイルで定義されているテーマとアクセントが、アプリ自体に埋め込まれるのではなく実行時にそのファイルの XAML から読み込まれるためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="dd092-258">ただし、これは XAML ファイルであるため、新しいプロジェクト システムでは、このファイルは自動的に `<Page>` として組み込まれます。</span><span class="sxs-lookup"><span data-stu-id="dd092-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="dd092-259">そのため、XAML ファイルをページとして削除 (`<Page Remove="**\Default.Accent.xaml" />`) することと、コンテンツとして追加することが両方とも必要です。</span><span class="sxs-lookup"><span data-stu-id="dd092-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="dd092-260">最後に、すべての `<PackageReference>` 要素とともに `<ItemGroup>` をコピーして、NuGet 参照を追加します。</span><span class="sxs-lookup"><span data-stu-id="dd092-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="dd092-261">まだ NuGet パッケージを .NET Core 互換バージョンにアップグレードしていない場合は、パッケージ参照が .NET Core 固有のプロジェクトに含まれるようになったので、それを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="dd092-262">この時点で、Bean Trader ソリューションに新しいプロジェクトを追加し、Visual Studio で開くことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="dd092-263">プロジェクトは **ソリューション エクスプローラー** で正しく表示され、`dotnet restore BeanTraderClient.Core.csproj` ではパッケージが正常に復元されているはずです (.NET Framework をターゲットとする、使用している MahApps.Metro バージョンに関連した 2 つの警告が出される可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="dd092-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="dd092-264">両方のプロジェクト ファイルを並行して保持することは可能ですが (古いプロジェクトを以前とまったく同じようにビルドし続ける場合は、これが望ましい場合もあります)、これによって移行プロセスが複雑になり (2 つのプロジェクトが同じ bin と obj フォルダーを使用しようとします)、通常は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="dd092-265">.NET Core と .NET Framework の両方のターゲット用にビルドする場合は、代わりに新しいプロジェクト ファイルの `<TargetFramework>netcoreapp3.0</TargetFramework>` プロパティを `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="dd092-266">Bean Trader サンプルでは、以前のプロジェクト ファイル (BeanTraderClient.csproj) は不要になるため、削除します。</span><span class="sxs-lookup"><span data-stu-id="dd092-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="dd092-267">両方のプロジェクト ファイルを保持する場合は、必ず異なる出力パスと中間出力パスにビルドするようにしてください。</span><span class="sxs-lookup"><span data-stu-id="dd092-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="dd092-268">ビルドの問題の修正</span><span class="sxs-lookup"><span data-stu-id="dd092-268">Fix build issues</span></span>

<span data-ttu-id="dd092-269">移植プロセスの 3 番目の手順は、プロジェクトをビルドすることです。</span><span class="sxs-lookup"><span data-stu-id="dd092-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="dd092-270">プロジェクト ファイルが SDK スタイルのプロジェクトに変換されると、その時点で一部のアプリは既に正常にビルドされます。</span><span class="sxs-lookup"><span data-stu-id="dd092-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="dd092-271">使用しているアプリがそうであれば幸運です。</span><span class="sxs-lookup"><span data-stu-id="dd092-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="dd092-272">手順 4 に進むことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-272">You can go on to Step 4.</span></span> <span data-ttu-id="dd092-273">その他のアプリでは、.NET Core 用にビルドするために、いくつかの更新を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="dd092-274">たとえば、この時点で Bean Trader サンプル プロジェクトで `dotnet build` を実行 (またはそれを Visual Studio でビルド) しようとすると、多くのエラーが発生しますが、すぐに修正できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="dd092-275">System.ServiceModel の参照と Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="dd092-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="dd092-276">エラーの一般的な原因として、.NET Core で利用可能でありながら、.NET Core アプリのメタパッケージに自動的に含まれない API の参照が欠落していることが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="dd092-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="dd092-277">これに対処するには、`Microsoft.Windows.Compatibility` パッケージを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="dd092-278">この互換性パッケージには、WCF クライアント、ディレクトリ サービス、レジストリ、構成、ACL API など、Windows デスクトップ アプリに共通するさまざまな API のセットが含まれています。</span><span class="sxs-lookup"><span data-stu-id="dd092-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="dd092-279">Bean Trader サンプルでは、ビルド エラーのほとんどは <xref:System.ServiceModel> 型が欠落していることが原因です。</span><span class="sxs-lookup"><span data-stu-id="dd092-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="dd092-280">これらは、必要な WCF NuGet パッケージを参照することで対処できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="dd092-281">ただし、WCF クライアント API は `Microsoft.Windows.Compatibility` パッケージに含まれるものの 1 つであるため、この互換性パッケージを参照すると、より効果的な解決策になります (これが、API に関連する問題の対策になり、この互換性パッケージによって提供される WCF の問題の解決策にもなるためです)。</span><span class="sxs-lookup"><span data-stu-id="dd092-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="dd092-282">`Microsoft.Windows.Compatibility` パッケージは、ほとんどの .NET Core 3.0 WPF と WinForms の移植のシナリオで役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dd092-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="dd092-283">`Microsoft.Windows.Compatibility` への NuGet の参照を追加すると、残るビルド エラーは 1 つだけになります。</span><span class="sxs-lookup"><span data-stu-id="dd092-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="dd092-284">使用されていないファイルのクリーンアップ</span><span class="sxs-lookup"><span data-stu-id="dd092-284">Cleaning up unused files</span></span>

<span data-ttu-id="dd092-285">移行に関して発生する問題の 1 つの種類として、以前はビルドに含まれていなかった C# と XAML のファイルが、"*すべての*" ソースが自動的に組み込まれる新しい SDK スタイルのプロジェクトによって取得されることに関連したものが多くあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="dd092-286">Bean Trader サンプルで発生する次のビルド エラーは、*OldUnusedViewModel.cs* でのインターフェイスの不適切な実装を指しています。</span><span class="sxs-lookup"><span data-stu-id="dd092-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="dd092-287">このファイル名がヒントになりますが、検査時に、このソース ファイルが正しくないことがわかります。</span><span class="sxs-lookup"><span data-stu-id="dd092-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="dd092-288">以前は、それによって問題は発生しませんでした。それが元の .NET Framework プロジェクトには含まれていなかったためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="dd092-289">ディスク上に存在していても以前の *csproj* に含まれていなかったソース ファイルは、自動的に含まれるようになっています。</span><span class="sxs-lookup"><span data-stu-id="dd092-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="dd092-290">このような 1 回限りの問題では、以前の *csproj* と比較してそのファイルが不要であることを確認し、それに対して `<Compile Remove="" />` を実行するか、そのソース ファイルがそれ以上どこにも必要でない場合は削除できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="dd092-291">この場合は、単に *OldUnusedViewModel.cs* を削除すれば問題ありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="dd092-292">この方法で除外する必要があるソース ファイルが多数ある場合は、プロジェクト ファイルで `<EnableDefaultCompileItems>` プロパティを false に設定して C# ファイルの自動組み込みを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="dd092-293">その後に、以前のプロジェクト ファイルから新しいものに `<Compile Include>` 項目をコピーすると、含める必要があるソースのみをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="dd092-294">同様に、`<EnableDefaultPageItems>` を使用すると XAML ページの自動組み込みをオフにすることができ、`<EnableDefaultItems>` によって 1 つのプロパティで両方を制御できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="dd092-295">マルチパス コンパイラに関する簡単な説明</span><span class="sxs-lookup"><span data-stu-id="dd092-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="dd092-296">Bean Trader サンプルから問題のあるファイルを削除した後に、再ビルドできますが、4 つのエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="dd092-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="dd092-297">以前はこれが発生しなかった可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-297">Didn't you have one before?</span></span> <span data-ttu-id="dd092-298">エラーの数が増えたのはなぜでしょうか。</span><span class="sxs-lookup"><span data-stu-id="dd092-298">Why did the number of errors go up?</span></span> <span data-ttu-id="dd092-299">C# コンパイラは[マルチパス コンパイラ](/archive/blogs/ericlippert/how-many-passes)です。</span><span class="sxs-lookup"><span data-stu-id="dd092-299">The C# compiler is a [multi-pass compiler](/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="dd092-300">これは、各ソース ファイルが 2 回確認されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="dd092-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="dd092-301">まずコンパイラでは、各ソース ファイルのメタデータと宣言が確認され、宣言レベルの問題が特定されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="dd092-302">これらは先ほど修正したエラーです。</span><span class="sxs-lookup"><span data-stu-id="dd092-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="dd092-303">次に、C# ソースを IL にビルドするためにコードがもう一度確認されます。これらが、現在検討している 2 番目のエラー セットです。</span><span class="sxs-lookup"><span data-stu-id="dd092-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="dd092-304">C# コンパイラでは、[単なる 2 回のパス以上のこと](/archive/blogs/ericlippert/how-many-passes)が行われますが、最終結果としては、このような大規模なコード変更でのコンパイラ エラーは 2 段階で発生する傾向にあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-304">The C# compiler does [more than just two passes](/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="dd092-305">サードパーティの依存関係の修正 (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="dd092-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="dd092-306">一部の移行シナリオで発生する別の種類の問題として、依存関係の .NET Framework と .NET Core バージョンの間の API の違いが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="dd092-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="dd092-307">NuGet パッケージが .NET Framework と .NET Standard または .NET Core の両方をターゲットとしている場合でも、さまざまな .NET ターゲットで使用する各種のライブラリが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="dd092-308">これにより、パッケージではさまざまな .NET プラットフォームがサポートされますが、複数の異なる実装が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="dd092-309">さらに、異なる .NET プラットフォームをターゲットとする場合に、ライブラリ内にわずかな API の違いが存在する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="dd092-310">Bean Trader サンプルで確認される次のエラー セットは、`Castle.Windsor` API に関連するものです。</span><span class="sxs-lookup"><span data-stu-id="dd092-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="dd092-311">.NET Core の Bean Trader プロジェクトでは、.NET Framework ターゲット プロジェクト (4.1.1) と同じバージョンの `Castle.Windsor` が使用されますが、これら 2 つのプラットフォームの実装には若干の違いがあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="dd092-312">この場合、修正が必要な次の問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="dd092-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="dd092-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` は .NET Core では使用できません。</span><span class="sxs-lookup"><span data-stu-id="dd092-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="dd092-314">ただし、類似の API `Classes.FromAssemblyContaining` を使用できるため、`Classes.FromThisAssembly()` の両方の使用を `Classes.FromAssemblyContaining(t)` の呼び出しに置き換えることができます。ここで、`t` は、呼び出しを行う型です。</span><span class="sxs-lookup"><span data-stu-id="dd092-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="dd092-315">同様に、*Bootstrapper.cs* では、`Castle.Windsor.Installer.FromAssembly` です。これは .NET Core では使用できません。</span><span class="sxs-lookup"><span data-stu-id="dd092-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="dd092-316">代わりに、その呼び出しを `FromAssembly.Containing(typeof(Bootstrapper))` に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="dd092-317">WCF クライアントの使用法の更新</span><span class="sxs-lookup"><span data-stu-id="dd092-317">Updating WCF client usage</span></span>

<span data-ttu-id="dd092-318">`Castle.Windsor` の違いを修正したので、.NET Core の Bean Trader プロジェクトで最後に残ったビルド エラーは、`BeanTraderServiceClient` (`DuplexClientBase` から派生) に `Open` メソッドがないことです。</span><span class="sxs-lookup"><span data-stu-id="dd092-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="dd092-319">これは意外なことではありません。これが、この移行プロセスの最初の段階で .NET Portability Analyzer によって示された API であるためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="dd092-320">ただし、`BeanTraderServiceClient` を調べることで、より大きな問題に注目することになります。</span><span class="sxs-lookup"><span data-stu-id="dd092-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="dd092-321">この WCF クライアントは、[Svcutil.exe](/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) ツールによって自動生成されました。</span><span class="sxs-lookup"><span data-stu-id="dd092-321">This WCF client was autogenerated by the [Svcutil.exe](/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool.</span></span>

<span data-ttu-id="dd092-322">**Svcutil によって生成される WCF クライアントは .NET Framework での使用を想定しています。**</span><span class="sxs-lookup"><span data-stu-id="dd092-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="dd092-323">Svcutil で生成された WCF クライアントを使用するソリューションでは、.NET Core で使用するための .NET Standard 互換クライアントを再生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="dd092-324">以前のクライアントが動作しない主な理由の 1 つは、それらが、WCF バインドとエンドポイントを定義するためにアプリ構成に依存していることです。</span><span class="sxs-lookup"><span data-stu-id="dd092-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="dd092-325">.NET Standard の WCF API はクロスプラットフォームで動作できるため (この場合、System.Configuration API は使用できません)、.NET Core と .NET Standard のシナリオ用の WCF クライアントでは、バインドとエンドポイントを、構成内ではなくプログラムで定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="dd092-326">実際、`<system.serviceModel>` app.config セクションに依存する WCF クライアント (Svcutil によって作成されたか手動で作成されたかに関係なく) の使用法を、.NET Core で機能するように変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="dd092-327">.NET Standard 互換の WCF クライアントを自動生成するには、次の 2 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="dd092-328">`dotnet-svcutil` ツールは、以前に Svcutil が動作していた方法と同様の方法で WCF クライアントを生成する .NET ツールです。</span><span class="sxs-lookup"><span data-stu-id="dd092-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="dd092-329">Visual Studio では、その接続済みサービス機能の [[WCF Web Service Reference]](/dotnet/core/additional-tools/wcf-web-service-reference-guide) オプションを使用して、WCF クライアントを生成できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](/dotnet/core/additional-tools/wcf-web-service-reference-guide) option of its Connected Services feature.</span></span>

<span data-ttu-id="dd092-330">どちらの方法も適切に機能します。</span><span class="sxs-lookup"><span data-stu-id="dd092-330">Either approach works well.</span></span> <span data-ttu-id="dd092-331">または、当然のことながら、WCF クライアント コードをご自身で記述することもできます。</span><span class="sxs-lookup"><span data-stu-id="dd092-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="dd092-332">このサンプルでは、Visual Studio の接続済みサービス機能を使用します。</span><span class="sxs-lookup"><span data-stu-id="dd092-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="dd092-333">これを行うには、Visual Studio のソリューション エクスプローラーで *BeanTraderClient.Core* プロジェクトを右クリックし、 **[追加]**  >  **[接続済みサービス]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="dd092-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="dd092-334">次に、WCF Web Service Reference Provider を選択します。</span><span class="sxs-lookup"><span data-stu-id="dd092-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="dd092-335">これによってイアログが表示され、そこでバックエンド Bean Trader Web サービスのアドレス (サーバーをローカルで実行している場合は `localhost:8080`) と、生成された型で使用する名前空間 (**BeanTrader.Service** など) を指定できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Service Reference の接続済みサービスのダイアログ](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="dd092-337">**[完了]** ボタンを選択すると、新しい接続済みサービス ノードがプロジェクトに追加され、そのノードの下に、Bean Trader サービスにアクセスするための新しい .NET Standard WCF クライアントを含む Reference.cs ファイルが追加されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="dd092-338">そのファイルの `GetEndpointAddress` または `GetBindingForEndpoint` メソッドを確認すると、バインドとエンドポイントが (アプリ構成によってではなく) プログラムで生成されるようになったことがわかります。</span><span class="sxs-lookup"><span data-stu-id="dd092-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="dd092-339">また、[接続済みサービスの追加] 機能を使用することで、プロジェクト ファイル内のいくつかの System.ServiceModel パッケージへの参照が追加される場合もあります。これは、必要なすべての WCF パッケージは Microsoft.Windows.Compatibility によって含まれるため、必要ありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="dd092-340">csproj を調べて、他の System.ServiceModel `<PackageReference>` 項目が追加されているかどうかを確認し、追加されている場合は削除してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="dd092-341">このプロジェクトには新しい WCF クライアント クラスが (*Reference.cs* 内に) 追加されていますが、以前のものも (BeanTrader.cs 内に) まだ存在します。</span><span class="sxs-lookup"><span data-stu-id="dd092-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="dd092-342">この時点で、次の 2 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-342">There are two options at this point:</span></span>

- <span data-ttu-id="dd092-343">元の .NET Framework プロジェクトを (.NET Core ターゲットの新しいものとともに) ビルドできるようにする場合は、.NET Core プロジェクトの csproj ファイルの `<Compile Remove="BeanTrader.cs" />` 項目を使用して、アプリの .NET Framework と .NET Core バージョンで異なる WCF クライアントが使用されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="dd092-344">これには、既存の .NET Framework プロジェクトが変更されないままになるという利点がありますが、生成された WCF クライアントを使用するコードが、.NET Core のケースでは場合によって .NET Framework プロジェクト内のときとは若干異なる必要があるという欠点もあります。そのため、`#if` ディレクティブを使用して、WCF クライアントの使用法 (たとえば、クライアントの作成) を条件付きでコンパイルして、.NET Core 用にビルドする際はある方法で動作し、.NET Framework 用にビルドする際は別の方法で動作するようにすることが必要になると考えられます。</span><span class="sxs-lookup"><span data-stu-id="dd092-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="dd092-345">一方、既存の .NET Framework プロジェクト内のコード チャーンを許容できる場合は、*BeanTrader.cs* をまとめて削除できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="dd092-346">新しい WCF クライアントは .NET Standard 用にビルドされているため、.NET Core と .NET Framework の両方のシナリオで動作します。</span><span class="sxs-lookup"><span data-stu-id="dd092-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="dd092-347">.NET Core に加えて .NET Framework 用にビルドする (マルチターゲットにより、または 2 つの csproj ファイルを使用することにより) 場合は、この新しい *Reference.cs* ファイルを両方のターゲットに使用できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="dd092-348">この方法には、2 つの異なる WCF クライアントをサポートするためにコードを 2 つに分ける必要がないという利点があります。同じコードがどこでも使われます。</span><span class="sxs-lookup"><span data-stu-id="dd092-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="dd092-349">欠点は、(安定していると想定される) .NET Framework プロジェクトの変更を伴うことです。</span><span class="sxs-lookup"><span data-stu-id="dd092-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="dd092-350">Bean Trader サンプルの場合、移行が簡単になるのであれば、元のプロジェクトにわずかな変更を加えることができます。そのため、次の手順に従って WCF クライアントの使用法を調整してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="dd092-351">ソリューション エクスプローラーの [既存項目の追加] コンテキスト メニューを使用して、.NET Framework の *BeanTraderClient.csproj* プロジェクトに新しい Reference.cs ファイルを追加します。</span><span class="sxs-lookup"><span data-stu-id="dd092-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="dd092-352">両方のプロジェクトで同じファイルが使用されるように、必ず 'as link' を追加してください (C# ファイルをコピーするのとは異なります)。</span><span class="sxs-lookup"><span data-stu-id="dd092-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="dd092-353">(マルチターゲットを使用して) 1 つの csproj で .NET Core と .NET Framework の両方をビルドする場合、この手順は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="dd092-354">*BeanTrader.cs* を削除します。</span><span class="sxs-lookup"><span data-stu-id="dd092-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="dd092-355">新しい WCF クライアントは以前のものと似ていますが、生成されるコードの名前空間の数が異なります。</span><span class="sxs-lookup"><span data-stu-id="dd092-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="dd092-356">このため、BeanTrader.Model ではなく BeanTrader.Service (または任意に選択した名前空間) から、または名前空間なしで、WCF クライアント型が使用されるように、プロジェクトを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dd092-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="dd092-357">*BeanTraderClient.Core.csproj* を作成すると、これらの変更が必要な場所を特定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dd092-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="dd092-358">修正は、C# と XAML の両方のソース ファイルで必要になります。</span><span class="sxs-lookup"><span data-stu-id="dd092-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="dd092-359">最後に、*BeanTraderServiceClientFactory.cs* 内にエラーがあることがわかります。これは、`BeanTraderServiceClient` 型で使用可能なコンストラクターが変更されたためです。</span><span class="sxs-lookup"><span data-stu-id="dd092-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="dd092-360">以前は、`InstanceContext` 引数 (`Castle.Windsor` IoC コンテナーから `CallbackHandler` を使用して作成されました) を指定できました。</span><span class="sxs-lookup"><span data-stu-id="dd092-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="dd092-361">新しいコンストラクターでは、新しい `CallbackHandler` が作成されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="dd092-362">ただし、`BeanTraderServiceClient` の基本型には、必要なものと一致するコンストラクターがあります。</span><span class="sxs-lookup"><span data-stu-id="dd092-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="dd092-363">自動生成された WCF クライアント コードはすべて部分クラスに存在するため、簡単に拡張できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="dd092-364">これを行うには、*BeanTraderServiceClient.cs* という名前の新しいファイルを作成してから、(BeanTrader.Service 名前空間を使用して) それと同じ名前の部分クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="dd092-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="dd092-365">その後、次に示すように、1 つのコンストラクターを部分型に追加します。</span><span class="sxs-lookup"><span data-stu-id="dd092-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="dd092-366">これらの変更を行うと、Bean Trader サンプルでは新しい .NET Standard 互換の WCF クライアントが使用されるようになり、*TradingService.cs* で、`await OpenAsync` を代わりに使用するように `Open` の呼び出しを変更するための最終的な修正を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="dd092-367">WCF の問題が解決されたので、.NET Core バージョンの Bean Trader サンプルが正常にビルドされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="dd092-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="dd092-368">ランタイムのテスト</span><span class="sxs-lookup"><span data-stu-id="dd092-368">Runtime testing</span></span>

<span data-ttu-id="dd092-369">忘れがちですが、.NET Core に対してプロジェクトが正常にビルドされてすぐに移行作業が完了するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="dd092-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="dd092-370">移植されたアプリをテストする時間を確保することも重要です。</span><span class="sxs-lookup"><span data-stu-id="dd092-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="dd092-371">ビルドが正常に完了したら、アプリが想定どおりに実行され、動作することを確認します (特に、.NET Framework をターゲットとするパッケージを使用している場合)。</span><span class="sxs-lookup"><span data-stu-id="dd092-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="dd092-372">移植された Bean Trader アプリを起動してみて、何が起こるか見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="dd092-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="dd092-373">まもなく、次の例外が発生してアプリが失敗します。</span><span class="sxs-lookup"><span data-stu-id="dd092-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="dd092-374">これは当然の結果です。</span><span class="sxs-lookup"><span data-stu-id="dd092-374">This makes sense, of course.</span></span> <span data-ttu-id="dd092-375">WCF ではアプリ構成が使用されなくなったため、app.config ファイルの以前の system.serviceModel セクションは削除する必要があることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="dd092-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="dd092-376">更新された WCF クライアントでは、そのコード内に同じ情報がすべて含まれているため、構成セクションは不要になりました。</span><span class="sxs-lookup"><span data-stu-id="dd092-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="dd092-377">WCF エンドポイントを app.config で構成できるようにする場合は、それをアプリ設定として追加し、構成から WCF サービス エンドポイントを取得するように WCF クライアント コードを更新できます。</span><span class="sxs-lookup"><span data-stu-id="dd092-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="dd092-378">*app.config* の system.serviceModel セクションを削除すると、アプリは起動しますが、ユーザーがサインインするときに別の例外が発生して失敗します。</span><span class="sxs-lookup"><span data-stu-id="dd092-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="dd092-379">サポートされていない API は `Func<T>.BeginInvoke` です。</span><span class="sxs-lookup"><span data-stu-id="dd092-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="dd092-380">[dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940) で説明されているように、.NET Core では、基になるリモート処理の依存関係が原因で、デリゲート型で `BeginInvoke` と `EndInvoke` メソッドはサポートされません。</span><span class="sxs-lookup"><span data-stu-id="dd092-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="dd092-381">この問題とその修正方法については、「[.NET Core の Delegate.BeginInvoke 呼び出しの移行](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)」ブログ記事で詳しく説明されていますが、要点としては、`BeginInvoke` と `EndInvoke` の呼び出しを `Task.Run` (または、可能な場合は非同期の代替手段) に置き換える必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="dd092-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="dd092-382">ここで一般的な解決策を適用すると、`BeginInvoke` の呼び出しを `Task.Run` によって起動される `Invoke` の呼び出しに置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="dd092-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="dd092-383">`BeginInvoke` の使用を削除すると、Bean Trader アプリが .NET Core で正常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="dd092-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![.NET Core で実行される Bean Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="dd092-385">すべてのアプリは異なっているため、ご自身のアプリを .NET Core に移行するために必要な具体的な手順もそれぞれ異なります。</span><span class="sxs-lookup"><span data-stu-id="dd092-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="dd092-386">しかし、この Bean Trader サンプルによって、一般的なワークフローと想定される問題の種類が示されることと思います。</span><span class="sxs-lookup"><span data-stu-id="dd092-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="dd092-387">また、この記事の長さとは対照的に、.NET Core で動作させるために Bean Trader サンプルに必要な実際の変更は、かなり限定されていました。</span><span class="sxs-lookup"><span data-stu-id="dd092-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="dd092-388">多くのアプリは、これと同じ方法で .NET Core に移行します。必要なコード変更は限定的であり、場合によっては一切不要です。</span><span class="sxs-lookup"><span data-stu-id="dd092-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
