---
title: XAML のマークアップ拡張機能の概要
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: 69f9d899b9a33d3de2fd7762990925138a47767c
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96983455"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="af235-102">XAML のマークアップ拡張機能の概要</span><span class="sxs-lookup"><span data-stu-id="af235-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="af235-103">マークアップ拡張機能は、プリミティブ型でも特定の XAML 型でもない値を取得するための XAML 手法です。</span><span class="sxs-lookup"><span data-stu-id="af235-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="af235-104">属性による使用では、マークアップ拡張機能は、左中かっこ `{` でマークアップ拡張機能スコープに入り、右中かっこ `}` で終了するという、既知の文字シーケンスを使用します。</span><span class="sxs-lookup"><span data-stu-id="af235-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="af235-105">.NET XAML サービスを使用する場合は、システムの .Xaml アセンブリから定義済みの XAML 言語マークアップ拡張機能の一部を使用できます。</span><span class="sxs-lookup"><span data-stu-id="af235-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="af235-106">また、System.Xaml で定義された <xref:System.Windows.Markup.MarkupExtension> クラスからサブクラスを作成し、独自のマークアップ拡張機能を定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="af235-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="af235-107">または、そのフレームワークを既に参照している場合は、特定のフレームワークによって定義されたマークアップ拡張機能を使用できます。</span><span class="sxs-lookup"><span data-stu-id="af235-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="af235-108">マークアップ拡張機能の使用にアクセスした XAML オブジェクト ライターは、 <xref:System.Windows.Markup.MarkupExtension> オーバーライドのサービス接続ポイントを通じて、カスタム <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> クラスにサービスを提供することができます。</span><span class="sxs-lookup"><span data-stu-id="af235-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="af235-109">このサービスを使用すると、使用に関するコンテキスト、オブジェクト ライターの特定の機能、XAML スキーマ コンテキストなどを取得することができます。</span><span class="sxs-lookup"><span data-stu-id="af235-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="af235-110">XAML で定義されたマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="af235-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="af235-111">いくつかのマークアップ拡張機能は、XAML 言語サポートのために .NET XAML サービスによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="af235-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="af235-112">これらのマークアップ拡張機能は、言語としての XAML の仕様の部分に対応しています。</span><span class="sxs-lookup"><span data-stu-id="af235-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="af235-113">これらは、通常、一般的に使用される構文では `x:` プレフィックスによって識別できます。</span><span class="sxs-lookup"><span data-stu-id="af235-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="af235-114">これらの XAML 言語要素に対する .NET XAML サービスの実装はすべて、  <xref:System.Windows.Markup.MarkupExtension> 基本クラスから派生します。</span><span class="sxs-lookup"><span data-stu-id="af235-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="af235-115">`x:` プレフィックスは、XAML 稼働環境のルート要素で、XAML 言語の名前空間を標準的な XAML 名前空間にマッピングするために使用します。</span><span class="sxs-lookup"><span data-stu-id="af235-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="af235-116">たとえば、さまざまな特定のフレームワークの Visual Studio プロジェクトとページテンプレートでは、このマッピングを使用して XAML ファイルが開始され `x:` ます。</span><span class="sxs-lookup"><span data-stu-id="af235-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="af235-117">独自の XAML 名前空間のマッピングに別のプレフィックス トークンを選択することもできますが、このドキュメントでは、既定の `x:` マッピングを、独自の固有なフレームワークの既定の XAML 名前空間や他の任意の CLR 名前空間または XML 名前空間ではなく、XAML 言語の XAML 名前空間の一部として定義されているエンティティを識別する手段と想定します。</span><span class="sxs-lookup"><span data-stu-id="af235-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="af235-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="af235-118">x:Type</span></span>

<span data-ttu-id="af235-119">`x:Type` は、名前を指定した型の <xref:System.Type> オブジェクトを提供します。</span><span class="sxs-lookup"><span data-stu-id="af235-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="af235-120">この機能は、基になる CLR 型やそれから派生した型をグループ化のモニカーまたは識別子として使用する遅延メカニズムの中で最も頻繁に使用されます。</span><span class="sxs-lookup"><span data-stu-id="af235-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="af235-121">具体的な例には、WPF のスタイルとテンプレート、およびそれらにおける `TargetType` プロパティの使用があります。</span><span class="sxs-lookup"><span data-stu-id="af235-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="af235-122">詳細については、「 [x:Type Markup Extension](xtype-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="af235-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="af235-123">x:Static</span></span>

<span data-ttu-id="af235-124">`x:Static` は、直接的にはプロパティの値の型ではなくても、その型に評価することができる値型コード エンティティから、静的な値を生成します。</span><span class="sxs-lookup"><span data-stu-id="af235-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="af235-125">これは、型定義で既知の定数として既に存在する値を指定するときに便利です。</span><span class="sxs-lookup"><span data-stu-id="af235-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="af235-126">詳細については、「 [x:Static Markup Extension](xstatic-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="af235-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="af235-127">x:Null</span></span>

<span data-ttu-id="af235-128">`x:Null` は、XAML メンバーに対する値として `null` を指定します。</span><span class="sxs-lookup"><span data-stu-id="af235-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="af235-129">特定の型の設計やフレームワークの広義の概念によっては、 `null` がプロパティの既定値に該当しない場合や、空の文字列属性の暗黙的な値に該当しない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="af235-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="af235-130">詳細については、「 [x:Null Markup Extension](xnull-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="af235-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="af235-131">x:Array</span></span>

<span data-ttu-id="af235-132">`x:Array` は、XAML 構文での一般的な配列の作成をサポートします。基本要素とコントロール モデルで提供されているコレクションのサポートをあえて使用しない場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="af235-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="af235-133">詳細については、「 [x:Array Markup Extension](xarray-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="af235-134">XAML 2009 では、厳密に言うと、拡張機能としてではなく言語プリミティブとして配列にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="af235-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="af235-135">詳細については、「 [XAML 2009 Language Features](xaml-2009-language-features.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="af235-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="af235-136">x:Reference</span></span>

<span data-ttu-id="af235-137">`x:Reference` は XAML 2009 に含まれており、元 (2006) の言語セットの拡張機能です。</span><span class="sxs-lookup"><span data-stu-id="af235-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="af235-138">`x:Reference` は、オブジェクト グラフにある別の既存のオブジェクトへの参照を表します。</span><span class="sxs-lookup"><span data-stu-id="af235-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="af235-139">このオブジェクトは、その `x:Name`によって識別されます。</span><span class="sxs-lookup"><span data-stu-id="af235-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="af235-140">詳細については、「 [x:Reference Markup Extension](xreference-markup-extension.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="af235-141">その他の x: コンストラクト</span><span class="sxs-lookup"><span data-stu-id="af235-141">Other x: Constructs</span></span>

<span data-ttu-id="af235-142">XAML 言語機能をサポートするための他の `x:` コンストラクトも存在しますが、マークアップ拡張機能としては実装されていません。</span><span class="sxs-lookup"><span data-stu-id="af235-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="af235-143">詳細については、「[XAML 名前空間 (x:) 言語機能](namespace-language-features.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="af235-144">MarkupExtension 基底クラス</span><span class="sxs-lookup"><span data-stu-id="af235-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="af235-145">System.Xaml の XAML リーダーと XAML ライターの既定の実装と対話できるカスタム マークアップ拡張機能を定義するには、抽象クラス <xref:System.Windows.Markup.MarkupExtension> からクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="af235-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="af235-146">このクラスには、オーバーライドする 1 つのメソッドとして、 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>があります。</span><span class="sxs-lookup"><span data-stu-id="af235-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="af235-147">また、マークアップ拡張機能で使用する引数をサポートする追加のコンストラクターと、それに対応する設定可能なプロパティも定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="af235-148">を通じて <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> 、カスタムマークアップ拡張機能は、XAML プロセッサによってマークアップ拡張機能が呼び出された環境を報告するサービスコンテキストにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="af235-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="af235-149">読み込みパスでは、これは通常 <xref:System.Xaml.XamlObjectWriter> です。</span><span class="sxs-lookup"><span data-stu-id="af235-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="af235-150">保存パスでは、これは通常 <xref:System.Xaml.XamlXmlWriter>です。</span><span class="sxs-lookup"><span data-stu-id="af235-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="af235-151">これらはそれぞれ、サービス プロバイダー パターンを実装する内部 XAML サービス プロバイダー コンテキスト クラスとして、サービス コンテキストを報告します。</span><span class="sxs-lookup"><span data-stu-id="af235-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="af235-152">使用できるサービスと、これらのサービスが何を表現するかについての詳細については、「 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af235-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="af235-153">マークアップ拡張機能クラスは、パブリックなアクセス レベルを使用する必要があります。XAML プロセッサは、マークアップ拡張機能のサービスを使用するために、そのマークアップ拡張機能のサポート クラスをいつでもインスタンス化できる必要があるからです。</span><span class="sxs-lookup"><span data-stu-id="af235-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="af235-154">カスタム マークアップ拡張機能のサポート型の定義</span><span class="sxs-lookup"><span data-stu-id="af235-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="af235-155">.Net xaml サービスまたは .NET XAML サービス上に構築されたフレームワークを使用する場合、マークアップ拡張機能のサポート型に名前を付ける方法には2つの選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="af235-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="af235-156">型名は、XAML オブジェクト ライターが XAML 内でマークアップ拡張機能の使用を検出したときに、マークアップ拡張機能のサポート型にアクセスして呼び出しを試みる方法に関連しています。</span><span class="sxs-lookup"><span data-stu-id="af235-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="af235-157">次のいずれかの方法で名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="af235-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="af235-158">XAML マークアップの使用トークンと完全に一致する型名を付ける。</span><span class="sxs-lookup"><span data-stu-id="af235-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="af235-159">たとえば、 `{Collate ...}` 拡張機能の使用をサポートするためには、サポート型に `Collate`という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="af235-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="af235-160">使用トークンの文字列に `Extension`サフィックスを付加した型名を付ける。</span><span class="sxs-lookup"><span data-stu-id="af235-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="af235-161">たとえば、 `{Collate ...}` 拡張機能の使用をサポートするためには、サポート型に `CollateExtension`という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="af235-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="af235-162">検索は、まずサフィックス `Extension`が付加されたクラス名、次にサフィックス `Extension` が付加されていないクラス名という順序で行われます。</span><span class="sxs-lookup"><span data-stu-id="af235-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="af235-163">マークアップを使用する観点からは、サフィックス `Extension` を使用名の一部に含めることは有効です。</span><span class="sxs-lookup"><span data-stu-id="af235-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="af235-164">ただし、この場合、 `Extension` は完全にクラス名の一部として扱われます。したがって、サポート クラスにサフィックス `Extension` が付いていない場合、XAML オブジェクト ライターはその使用についてマークアップ拡張機能のサポート クラスを解決できません。</span><span class="sxs-lookup"><span data-stu-id="af235-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="af235-165">パラメーターなしのコンストラクター</span><span class="sxs-lookup"><span data-stu-id="af235-165">The parameterless constructor</span></span>

<span data-ttu-id="af235-166">すべてのマークアップ拡張機能のサポート型について、パブリックなパラメーターなしのコンストラクターを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="af235-167">XAML オブジェクトライターがオブジェクト要素の使用からマークアップ拡張機能をインスタンス化する場合は、パラメーターなしのコンストラクターが必要です。</span><span class="sxs-lookup"><span data-stu-id="af235-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="af235-168">マークアップ拡張機能でオブジェクト要素の使用がサポートされることは、特にシリアル化の場合には、正当な予想です。</span><span class="sxs-lookup"><span data-stu-id="af235-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="af235-169">ただし、マークアップ拡張機能の属性による使用だけをサポートする場合は、パブリック コンストラクターなしでマークアップ拡張機能を実装することができます。</span><span class="sxs-lookup"><span data-stu-id="af235-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="af235-170">マークアップ拡張機能の使用に引数がない場合は、使用をサポートするためにパラメーターなしのコンストラクターが必要です。</span><span class="sxs-lookup"><span data-stu-id="af235-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="af235-171">カスタム マークアップ拡張機能のコンストラクター パターンと位置指定引数</span><span class="sxs-lookup"><span data-stu-id="af235-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="af235-172">引数の意図された使用方法のあるマークアップ拡張機能については、パブリック コンストラクターは、意図された使用方法のモードに対応する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="af235-173">つまり、有効な使用方法として位置指定引数を 1 つ使用するようにマークアップ拡張機能が設計されている場合であれば、その位置指定引数を取る 1 つの入力パラメーターを使用するパブリック コンストラクターをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="af235-174">たとえば、 `Collate` マークアップ拡張機能が、モードを表す位置指定引数 ( `CollationMode` 列挙定数として指定される) が 1 つのモードのみをサポートするとします。</span><span class="sxs-lookup"><span data-stu-id="af235-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="af235-175">この場合は、次の形式のコンストラクターが必要になります。</span><span class="sxs-lookup"><span data-stu-id="af235-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="af235-176">基本的なレベルでは、マークアップ拡張機能に渡される引数は、マークアップの属性値から転送されるので、文字列です。</span><span class="sxs-lookup"><span data-stu-id="af235-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="af235-177">すべての引数を文字列にし、入力をそのレベルで処理することができます。</span><span class="sxs-lookup"><span data-stu-id="af235-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="af235-178">ただし、マークアップ拡張機能の引数がサポート クラスに渡される前に実行される特定の処理にアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="af235-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="af235-179">この処理では、概念としては、マークアップ拡張機能を「作成するオブジェクト」と見なして、そのメンバー値を設定します。</span><span class="sxs-lookup"><span data-stu-id="af235-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="af235-180">設定するように指定された各プロパティは、作成するオブジェクトに指定されたメンバーが設定される場合と同じように、XAML が解析される時点で評価されます。</span><span class="sxs-lookup"><span data-stu-id="af235-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="af235-181">次の 2 つの重要な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="af235-181">There are two important differences:</span></span>

- <span data-ttu-id="af235-182">前述のように、マークアップ拡張機能のサポート型では、XAML でインスタンス化するために、パラメーターなしのコンストラクターを持つ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="af235-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="af235-183">オブジェクトの構築は、テキスト構文で使用できる引数が位置指定引数または名前付き引数のいずれかとしてトークン化および評価されるまで遅延され、その時点で適切なコンストラクターが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="af235-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="af235-184">マークアップ拡張機能の使用は入れ子にすることができます。</span><span class="sxs-lookup"><span data-stu-id="af235-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="af235-185">最も内側のマークアップ拡張機能が最初に評価されます。</span><span class="sxs-lookup"><span data-stu-id="af235-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="af235-186">そのため、そのような使用を想定して、いずれかの構築パラメーターを、生成するために値コンバーター (マークアップ拡張機能など) を必要とする型として宣言できます。</span><span class="sxs-lookup"><span data-stu-id="af235-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="af235-187">このような処理への依存については、前の例で説明したとおりです。</span><span class="sxs-lookup"><span data-stu-id="af235-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="af235-188">.NET XAML サービスの XAML オブジェクトライターは、列挙定数名をネイティブレベルで列挙値に処理します。</span><span class="sxs-lookup"><span data-stu-id="af235-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="af235-189">また、マークアップ拡張機能の位置指定パラメーターのテキスト構文を処理する際にも、構築引数にある型に関連付けた型コンバーターに依存するようにできます。</span><span class="sxs-lookup"><span data-stu-id="af235-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="af235-190">引数が位置指定引数と呼ばれるのは、使用の中でトークンに出会う順序が、割り当てられたコンストラクター パラメーターの位置的な順序に対応するからです。</span><span class="sxs-lookup"><span data-stu-id="af235-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="af235-191">たとえば、次のようなコンストラクター シグネチャについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="af235-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="af235-192">XAML プロセッサは、このマークアップ拡張機能に対して、2 つの位置指定引数を予期します。</span><span class="sxs-lookup"><span data-stu-id="af235-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="af235-193">`{Collate AlphaUp,{x:Reference circularFile}}`という使用があった場合、 `AlphaUp` トークンが最初のパラメーターに送られ、 `CollationMode` 列挙体の名前付き定数として評価されます。</span><span class="sxs-lookup"><span data-stu-id="af235-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="af235-194">内側の `x:Reference` の結果は 2 つ目のパラメーターに送られ、オブジェクトとして評価されます。</span><span class="sxs-lookup"><span data-stu-id="af235-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="af235-195">XAML で規定されているマークアップ拡張構文と処理の規則では、引数が位置指定引数の場合でも名前付き引数の場合でも、引数の区切り記号としてコンマが使用されます。</span><span class="sxs-lookup"><span data-stu-id="af235-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="af235-196">位置指定引数の重複するアリティ</span><span class="sxs-lookup"><span data-stu-id="af235-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="af235-197">XAML オブジェクト ライターが位置指定引数によるマークアップ拡張機能の使用を検出したときに、同じ数の引数 (重複するアリティ) を受け取る複数のコンストラクターが存在している場合でも、必ずしもエラーには該当しません。</span><span class="sxs-lookup"><span data-stu-id="af235-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="af235-198">実際の動作は、カスタマイズ可能な XAML スキーマ コンテキスト設定である <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>によって異なります。</span><span class="sxs-lookup"><span data-stu-id="af235-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="af235-199"><xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> が `true`である場合は、重複するアリティのみを理由に、XAML オブジェクト ライターから例外がスローされることはありません。</span><span class="sxs-lookup"><span data-stu-id="af235-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="af235-200">それ以上の動作は、厳密には定義されていません。</span><span class="sxs-lookup"><span data-stu-id="af235-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="af235-201">基本的な設計では、スキーマ コンテキストには特定のパラメーターに対応する型情報が設定されており、明示的なキャストを試みて、重複する候補から最もよく一致するシグネチャを確認できる、ということを前提としています。</span><span class="sxs-lookup"><span data-stu-id="af235-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="af235-202">それでも、XAML オブジェクト ライターで実行されている特定のスキーマ コンテキストによってテストが行われ、そのテストに合格するシグネチャが存在しない場合に、例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="af235-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="af235-203">既定で <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> は、は `false` CLR ベース <xref:System.Xaml.XamlSchemaContext> の .net XAML サービスに含まれています。</span><span class="sxs-lookup"><span data-stu-id="af235-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="af235-204">したがって、バッキング型のコンストラクターに重複するアリティが存在している状況で、マークアップ拡張機能の使用を検出した場合に、既定の <xref:System.Xaml.XamlObjectWriter> が例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="af235-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="af235-205">カスタムマークアップ拡張機能の名前付き引数</span><span class="sxs-lookup"><span data-stu-id="af235-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="af235-206">XAML によって指定されるマークアップ拡張機能は、使用の際に名前付き引数の形式を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="af235-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="af235-207">トークン化の最初のレベルでは、テキスト構文は引数に分割されます。</span><span class="sxs-lookup"><span data-stu-id="af235-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="af235-208">引数内に等号 (=) が存在すると、引数は名前付き引数として識別されます。</span><span class="sxs-lookup"><span data-stu-id="af235-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="af235-209">このような引数は、名前と値のペアにトークン化されます。</span><span class="sxs-lookup"><span data-stu-id="af235-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="af235-210">この場合の名前は、マークアップ拡張機能のサポート型の、パブリックに設定可能なプロパティの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="af235-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="af235-211">名前付き引数の使用をサポートする場合は、これらのパブリックに設定可能なプロパティを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="af235-212">プロパティは、パブリックである限りは、継承プロパティを指定できます。</span><span class="sxs-lookup"><span data-stu-id="af235-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="af235-213">マークアップ拡張機能の実装からサービス プロバイダーのコンテキストにアクセスする</span><span class="sxs-lookup"><span data-stu-id="af235-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="af235-214">使用可能なサービスは、すべての値コンバーターの場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="af235-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="af235-215">ただし、それぞれの値コンバーターがサービス コンテキストを受け取る方法が違います。</span><span class="sxs-lookup"><span data-stu-id="af235-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="af235-216">サービスへのアクセスと、使用できるサービスについては、「 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)」のトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="af235-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="af235-217">マークアップ拡張機能のプロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="af235-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="af235-218">マークアップ拡張機能の使用のシナリオは、多くの場合、属性を使用したマークアップ拡張機能の使用を中心にして設計されます。</span><span class="sxs-lookup"><span data-stu-id="af235-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="af235-219">ただし、プロパティ要素による使用をサポートするバッキング クラスを定義することも可能です。</span><span class="sxs-lookup"><span data-stu-id="af235-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="af235-220">マークアップ拡張機能のプロパティ要素の使用をサポートするには、パラメーターなしのパブリックコンストラクターを定義します。</span><span class="sxs-lookup"><span data-stu-id="af235-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="af235-221">これは、静的コンストラクターではなく、インスタンス コンストラクターにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="af235-222">XAML プロセッサは通常、マークアップから処理するオブジェクト要素のパラメーターなしのコンストラクターを呼び出す必要があり、これにはオブジェクト要素としてマークアップ拡張クラスが含まれているため、これが必要になります。</span><span class="sxs-lookup"><span data-stu-id="af235-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="af235-223">さらに複雑なシナリオとして、クラスに対して既定以外の構築パスを定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="af235-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="af235-224">(詳細については、「 [X:FactoryMethod ディレクティブ](xfactorymethod-directive.md)」を参照してください)。ただし、マークアップ拡張機能の目的では、これらのパターンを使用しないでください。これにより、デザイナーと生のマークアップのユーザーの両方で、使用パターンの検出がはるかに困難になります。</span><span class="sxs-lookup"><span data-stu-id="af235-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="af235-225">カスタムマークアップ拡張機能の属性</span><span class="sxs-lookup"><span data-stu-id="af235-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="af235-226">デザイン環境と、特定の XAML オブジェクト ライターのシナリオのどちらをサポートするためにも、マークアップ拡張機能のサポート型にいくつかの CLR 属性を設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="af235-227">これらの属性は、目的のマークアップ拡張機能の使用を報告します。</span><span class="sxs-lookup"><span data-stu-id="af235-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="af235-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> は、 <xref:System.Type> が返すオブジェクトの型の <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 情報を報告します。</span><span class="sxs-lookup"><span data-stu-id="af235-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="af235-229">純粋なシグネチャとしては、 <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> は <xref:System.Object>を返します。</span><span class="sxs-lookup"><span data-stu-id="af235-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="af235-230">ただし、コンシューマーの種類によっては、戻り値の型についてさらに詳細な情報が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="af235-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="af235-231">これには次のものが含まれます</span><span class="sxs-lookup"><span data-stu-id="af235-231">This includes:</span></span>

- <span data-ttu-id="af235-232">マークアップ拡張機能の使用に関して、型を認識したサポートを提供できるデザイナーや IDE を実現するための情報。</span><span class="sxs-lookup"><span data-stu-id="af235-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="af235-233">ターゲット クラスに対する `SetMarkupExtension` ハンドラーの高度な実装のための情報。特定の既知の <xref:System.Windows.Markup.MarkupExtension> 実装を名前で分岐して判別するのではなく、リフレクションに基づいてマークアップ拡張機能の戻り値の型を判別できるようになります。</span><span class="sxs-lookup"><span data-stu-id="af235-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="af235-234">マークアップ拡張機能の使用のシリアル化</span><span class="sxs-lookup"><span data-stu-id="af235-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="af235-235">XAML オブジェクト ライターによってマークアップ拡張機能の使用が処理され、 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>が呼び出されると、かつてマークアップ拡張機能の使用だったコンテキストは XAML ノード ストリームに残りますが、オブジェクト グラフには残りません。</span><span class="sxs-lookup"><span data-stu-id="af235-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="af235-236">オブジェクト グラフでは、値だけが保持されます。</span><span class="sxs-lookup"><span data-stu-id="af235-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="af235-237">元のマークアップ拡張機能の使用をシリアル化された出力として保持する、設計シナリオとしての必要性や他の理由がある場合は、読み込みパスの XAML ノード ストリームからマークアップ拡張機能の使用を追跡するための独自のインフラストラクチャを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="af235-238">読み込みパスからノード ストリームの要素を再作成し、ノード ストリームの該当する位置に値を代入しながら、それらを XAML ライターで再生して保存パスにシリアル化する、という動作を実装できます。</span><span class="sxs-lookup"><span data-stu-id="af235-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="af235-239">XAML ノードストリームのマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="af235-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="af235-240">読み込みパスで XAML ノード ストリームを処理している場合、マークアップ拡張機能の使用は、オブジェクトとしてノード ストリーム内に登場します。</span><span class="sxs-lookup"><span data-stu-id="af235-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="af235-241">マークアップ拡張機能の使用で位置指定引数が使用される場合、その使用は初期化の値が設定された開始オブジェクトとして表されます。</span><span class="sxs-lookup"><span data-stu-id="af235-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="af235-242">大まかなテキスト表現では、ノード ストリームは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="af235-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="af235-243">`StartObject` (<xref:System.Xaml.XamlType> はマークアップ拡張機能の定義の型であり、戻り値の型ではありません)</span><span class="sxs-lookup"><span data-stu-id="af235-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="af235-244">`StartMember` ( <xref:System.Xaml.XamlMember> の名前は `_InitializationText`)</span><span class="sxs-lookup"><span data-stu-id="af235-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="af235-245">`Value` (値は、途中に区切り記号を含む文字列形式の位置指定引数)</span><span class="sxs-lookup"><span data-stu-id="af235-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="af235-246">名前付き引数によるマークアップ拡張機能の使用は、その名前のメンバー (それぞれにテキスト文字列値が設定されている) を持つオブジェクトとして表されます。</span><span class="sxs-lookup"><span data-stu-id="af235-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="af235-247">実際にマークアップ拡張機能の `ProvideValue` 実装を呼び出すには、XAML スキーマ コンテキストが必要です。その呼び出しには、型マッピングと、マークアップ拡張機能のサポート型インスタンスの作成が必要であるからです。</span><span class="sxs-lookup"><span data-stu-id="af235-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="af235-248">これは、既定の .NET XAML サービスのノードストリームでマークアップ拡張機能の使用がこのように保持される理由の1つです。読み込みパスのリーダー部分には、必要な XAML スキーマコンテキストを使用できないことがよくあります。</span><span class="sxs-lookup"><span data-stu-id="af235-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="af235-249">保存パスで XAML ノード ストリームを処理している場合は、通常、シリアル化するオブジェクトが当初はマークアップ拡張機能の使用と `ProvideValue` の結果によって提供されたことを知らせる情報はオブジェクト グラフ表現の中に存在しません。</span><span class="sxs-lookup"><span data-stu-id="af235-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="af235-250">マークアップ拡張機能の使用をラウンドトリップさせ、オブジェクト グラフのその他の変化もキャプチャする必要があるシナリオでは、元の XAML 入力に由来するマークアップ拡張機能の使用の情報を保存するため、独自の手法を考案する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af235-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="af235-251">たとえば、マークアップ拡張機能の使用を復元するには、保存パス上のノード ストリームを処理してマークアップ拡張機能の使用を復元するか、元の XAML とラウンドトリップされた XAML に対して何らかのマージ処理を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="af235-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="af235-252">WPF などの一部の XAML 実装フレームワークでは、中間の型 (式) を使用して、マークアップ拡張機能の使用が値を提供したケースを表す場合があります。</span><span class="sxs-lookup"><span data-stu-id="af235-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="af235-253">関連項目</span><span class="sxs-lookup"><span data-stu-id="af235-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="af235-254">XAML の型コンバーターおよびマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="af235-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="af235-255">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="af235-255">Markup Extensions and WPF XAML</span></span>](../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)
