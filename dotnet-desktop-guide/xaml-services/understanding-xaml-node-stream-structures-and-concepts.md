---
title: XAML ノード ストリームの構造と概念について
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96981868"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="92a82-102">XAML ノードストリームの構造と概念</span><span class="sxs-lookup"><span data-stu-id="92a82-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="92a82-103">.NET XAML サービスに実装されている XAML リーダーと XAML ライターは、XAML ノードストリームの設計概念に基づいています。</span><span class="sxs-lookup"><span data-stu-id="92a82-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="92a82-104">XAML ノード ストリームは、一連の XAML ノードを概念化したものです。</span><span class="sxs-lookup"><span data-stu-id="92a82-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="92a82-105">この概念化では、XAML プロセッサは、XAML 内のノードのリレーションシップの構造を 1 つずつ処理します。</span><span class="sxs-lookup"><span data-stu-id="92a82-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="92a82-106">常に、開いている XAML ノード ストリームに存在する現在のレコードまたは現在の位置は 1 つのみで、API の多くの側面がレポートするのは、その位置から入手できる情報のみです。</span><span class="sxs-lookup"><span data-stu-id="92a82-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="92a82-107">XAML ノード ストリームの現在のノードは、オブジェクト、メンバー、または値として記述できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="92a82-108">XAML を XAML ノード ストリームとして扱うことで、XAML リーダーは XAML ライターと通信するとともに、XAML に関するパスの読み込みまたはパスの保存操作中に、XAML ノード ストリームのコンテンツをプログラムが表示、操作、または変更できるようにします。</span><span class="sxs-lookup"><span data-stu-id="92a82-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="92a82-109">XAML リーダーおよびライター API の設計と XAML ノードストリームの概念は、前に関連するリーダーとライターの設計と概念 (XML ドキュメントオブジェクトモデル (DOM)、クラス、クラスなど) に似てい <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> ます。</span><span class="sxs-lookup"><span data-stu-id="92a82-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="92a82-110">このトピックでは、XAML ノード ストリームの概念について説明するとともに、XAML ノード レベルで XAML 表現と対話するルーチンを記述する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="92a82-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="92a82-111">XAML リーダーに XAML を読み込む</span><span class="sxs-lookup"><span data-stu-id="92a82-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="92a82-112"><xref:System.Xaml.XamlReader> 基底クラスは、初期の XAML を XAML リーダーに読み込む特定の手法を宣言しません。</span><span class="sxs-lookup"><span data-stu-id="92a82-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="92a82-113">代わりに、派生クラスが、XAML の一般的な特性と入力ソースの制約などの読み込みの手法を宣言および実装します。</span><span class="sxs-lookup"><span data-stu-id="92a82-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="92a82-114">たとえば、 <xref:System.Xaml.XamlObjectReader> は、オブジェクト グラフの読み取りを、ルートまたはベースを表す 1 つのオブジェクトの入力ソースから開始します。</span><span class="sxs-lookup"><span data-stu-id="92a82-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="92a82-115"><xref:System.Xaml.XamlObjectReader> はその後、オブジェクト グラフから XAML ノード ストリームを生成します。</span><span class="sxs-lookup"><span data-stu-id="92a82-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="92a82-116">.NET XAML サービスで定義されている最も目立つ <xref:System.Xaml.XamlReader> サブクラスは <xref:System.Xaml.XamlXmlReader> です。</span><span class="sxs-lookup"><span data-stu-id="92a82-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="92a82-117"><xref:System.Xaml.XamlXmlReader> は、初期の XAML を、直接ストリームまたはファイルのパスを経由してテキスト ファイル読み込むか、 <xref:System.IO.TextReader>などの関連するリーダー クラスを経由して間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="92a82-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="92a82-118"><xref:System.Xaml.XamlReader> は、XAML 入力ソースが読み込まれた後には、その全体を格納していると考えることができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="92a82-119">ただし、 <xref:System.Xaml.XamlReader> のベース API は、リーダーが XAML の 1 つのノードと対話するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="92a82-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="92a82-120">初めて読み込まれるときに表示される最初の 1 つのノードは、XAML のルートとその開始オブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="92a82-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="92a82-121">XAML ノード ストリームの概念</span><span class="sxs-lookup"><span data-stu-id="92a82-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="92a82-122">DOM、ツリーの比喩、または XML ベースのテクノロジにアクセスするためのクエリベースのアプローチについて詳しく理解している場合は、次のようにして XAML ノードストリームの概念を理解することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="92a82-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="92a82-123">読み込まれた XAML が、 DOM またはツリーで、可能な限りすべてのノードが幅広く拡張され、直線的に表示されるところを想像してください。</span><span class="sxs-lookup"><span data-stu-id="92a82-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="92a82-124">ノードを進んでいくうちに、DOM に関連するレベルの " in" または "out" レベルを走査することがありますが、これらのレベルの概念はノード ストリームと関係がないため、XAML ノード ストリームは明示的に追跡しません。</span><span class="sxs-lookup"><span data-stu-id="92a82-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="92a82-125">ノード ストリームには、「現在の」位置がありますが、参照として自分でストリームのその他の部分を格納していない限り、現在のノードの位置を除くノード ストリームのすべての側面は表示されません。</span><span class="sxs-lookup"><span data-stu-id="92a82-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="92a82-126">XAML ノード ストリームの概念には、ノード ストリーム全体を通過すると、XAML 表現全体が処理されたことが保証されるという大きな利点があります。情報を処理するためのクエリ、DOM の操作、またはその他の非線形アプローチで、完全な XAML 表現の一部が不足していると心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="92a82-127">このため、XAML ノード ストリーム表現は、XAML リーダーと XAML ライターの両方の接続、および XAML 処理操作の読み取りと書き込みの各フェーズの間で動作する独自のプロセスを挿入できるシステムを用意するのに最適です。</span><span class="sxs-lookup"><span data-stu-id="92a82-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="92a82-128">多くの場合、XAML ノード ストリーム内のノードの順序付けは、順序がソース テキスト、バイナリ、またはオブジェクト グラフで表示されるしくみと比較して、XAML リーダーによって意図的に最適化または表示されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="92a82-129">この動作は、ノード ストリームにおいて、XAML ライターが「戻る」必要がある位置に存在しない XAML 処理アーキテクチャを適用することを意図しています。</span><span class="sxs-lookup"><span data-stu-id="92a82-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="92a82-130">理想としては、すべての XAML の書き込み操作が、スキーマ コンテキストとノード ストリームの現在の位置に基づいて動作できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="92a82-131">基本的な読み取りノードのループ</span><span class="sxs-lookup"><span data-stu-id="92a82-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="92a82-132">XAML ノード ストリームを検査するための基本的な読み取りノードのループは、次の概念で構成されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="92a82-133">このトピックで説明したようなノード ループの目的から、 <xref:System.Xaml.XamlXmlReader>を使用して人間が判読できるテキスト ベースの XAML ファイルを読み取ることを想定してください。</span><span class="sxs-lookup"><span data-stu-id="92a82-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="92a82-134">このセクションのリンクは、 <xref:System.Xaml.XamlXmlReader>が実装する特別な XAML ノード ループ API を指しています。</span><span class="sxs-lookup"><span data-stu-id="92a82-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="92a82-135">XAML ノード ストリームの終わりになっていないことを確認してください ( <xref:System.Xaml.XamlXmlReader.IsEof%2A>を確認するか、 <xref:System.Xaml.XamlXmlReader.Read%2A> の戻り値を使用します)。</span><span class="sxs-lookup"><span data-stu-id="92a82-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="92a82-136">ストリームの終わりになっている場合は、現在のノードはないため、終了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="92a82-137"><xref:System.Xaml.XamlXmlReader.NodeType%2A>を呼び出して、XAML ノード ストリームが現在どのような種類のノードを公開しているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="92a82-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="92a82-138">直接接続されている、関連する XAML オブジェクト ライターを使用している場合は、通常はこの時点で <xref:System.Xaml.XamlWriter.WriteNode%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="92a82-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="92a82-139">どの <xref:System.Xaml.XamlNodeType> が現在のノードまたは現在のレコードとして報告されているかに基づいて、次のいずれかを呼び出して、ノードのコンテンツに関する情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="92a82-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="92a82-140"><xref:System.Xaml.XamlXmlReader.NodeType%2A> または <xref:System.Xaml.XamlNodeType.StartMember> の <xref:System.Xaml.XamlNodeType.EndMember>の場合、 <xref:System.Xaml.XamlXmlReader.Member%2A> を呼び出して、メンバーに関する <xref:System.Xaml.XamlMember> の情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="92a82-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="92a82-141">メンバーはである可能性がある <xref:System.Xaml.XamlDirective> ため、必ずしも前のオブジェクトの従来の型定義のメンバーであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="92a82-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="92a82-142">たとえば、オブジェクトに適用された `x:Name` は XAML メンバーとして表示されます。ここで、 <xref:System.Xaml.XamlMember.IsDirective%2A> は true、メンバーの <xref:System.Xaml.XamlMember.Name%2A> は `Name`で、このディレクティブが XAML 言語の XAML 名前空間の下にあることを示すその他のプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="92a82-143"><xref:System.Xaml.XamlXmlReader.NodeType%2A> または <xref:System.Xaml.XamlNodeType.StartObject> の <xref:System.Xaml.XamlNodeType.EndObject>の場合は、 <xref:System.Xaml.XamlXmlReader.Type%2A> を呼び出して、オブジェクトに関する <xref:System.Xaml.XamlType> の情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="92a82-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="92a82-144"><xref:System.Xaml.XamlXmlReader.NodeType%2A> の <xref:System.Xaml.XamlNodeType.Value>で、 <xref:System.Xaml.XamlXmlReader.Value%2A>を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="92a82-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="92a82-145">ノードがメンバーの最も単純な表現である場合、またはオブジェクトの初期化のテキストである場合のみ、ノードは値になります (ただし、このトピックの以下のセクションに記載する型変換の動作に注意する必要があります)。</span><span class="sxs-lookup"><span data-stu-id="92a82-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="92a82-146"><xref:System.Xaml.XamlXmlReader.NodeType%2A> の <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>の場合は、 <xref:System.Xaml.XamlXmlReader.Namespace%2A> を呼び出して、名前空間ノードの名前空間情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="92a82-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="92a82-147"><xref:System.Xaml.XamlXmlReader.Read%2A> を呼び出して、XAML リーダーを XAML ノード ストリームの次のノードに進め、手順を繰り返します。</span><span class="sxs-lookup"><span data-stu-id="92a82-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="92a82-148">.NET XAML サービスの XAML リーダーによって提供される XAML ノードストリームは、すべての可能なノードの完全なディープトラバーサルを常に提供します。</span><span class="sxs-lookup"><span data-stu-id="92a82-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="92a82-149">XAML ノード ループの一般的なフロー制御の手法には、 `while (reader.Read())`内の本文の定義、およびノード ループの各ノード ポイントにおける <xref:System.Xaml.XamlXmlReader.NodeType%2A> の切り替えなどがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="92a82-150">ノード ストリームがファイルの終わりにある場合、現在のノードは null です。</span><span class="sxs-lookup"><span data-stu-id="92a82-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="92a82-151">リーダーとライターを使用する最も簡単なループは、次の例に似ています。</span><span class="sxs-lookup"><span data-stu-id="92a82-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="92a82-152">読み込みパスの XAML ノード ループの基本的な例では、XAML リーダーと XAML ライターが透過的に接続されています。 <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>を使用した場合と違いはありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="92a82-153">しかし、この基本構造は、読み取りと書き込みのシナリオに適用するように拡張されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="92a82-154">可能なシナリオは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="92a82-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="92a82-155"><xref:System.Xaml.XamlXmlReader.NodeType%2A>で切り替える。</span><span class="sxs-lookup"><span data-stu-id="92a82-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="92a82-156">読み込まれているノードの型によって、さまざまな操作を実行する。</span><span class="sxs-lookup"><span data-stu-id="92a82-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="92a82-157">どの場合にも <xref:System.Xaml.XamlWriter.WriteNode%2A> を呼び出さない。</span><span class="sxs-lookup"><span data-stu-id="92a82-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="92a82-158">一部の <xref:System.Xaml.XamlWriter.WriteNode%2A> の場合のみ <xref:System.Xaml.XamlXmlReader.NodeType%2A> を呼び出す。</span><span class="sxs-lookup"><span data-stu-id="92a82-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="92a82-159">特定のノード型のロジックで、そのノードの詳細を分析して操作します。</span><span class="sxs-lookup"><span data-stu-id="92a82-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="92a82-160">たとえば、特定の XAML 名前空間からのオブジェクトを作成し、その XAML 名前空間からではないオブジェクトを削除するか、遅延させることができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="92a82-161">または、XAML システムがメンバーの処理の一部としてサポートしていないすべての XAML ディレクティブを削除または再処理することができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="92a82-162"><xref:System.Xaml.XamlObjectWriter> メソッドをオーバーライドするカスタムの `Write*` を定義します。場合によっては XAML スキーマ コンテキストをバイパスする型マッピングを実行します。</span><span class="sxs-lookup"><span data-stu-id="92a82-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="92a82-163">XAML の動作の違いのカスタマイズをリーダーとライターの両方で使用できるように、 <xref:System.Xaml.XamlXmlReader> を構築して既定以外の XAML スキーマ コンテキストを使用します。</span><span class="sxs-lookup"><span data-stu-id="92a82-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="92a82-164">ノード ループの概念を超えた XAML へのアクセス</span><span class="sxs-lookup"><span data-stu-id="92a82-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="92a82-165">XAML ノード ループとして使用する以外に XAML 表現を使用する可能性があるその他の方法があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="92a82-166">たとえば、インデックス付きのノードを読み取ることができる XAML リーダー、特に `x:Name`、 `x:Uid`、またはその他の識別子を介して直接ノードにアクセスする XAML リーダーが存在することがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="92a82-167">.NET XAML サービスは完全な実装を提供しませんが、サービスとサポートの種類を通じて推奨されるパターンを提供します。</span><span class="sxs-lookup"><span data-stu-id="92a82-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="92a82-168">詳細については、次のトピックを参照してください。 <xref:System.Xaml.IXamlIndexingReader> および <xref:System.Xaml.XamlNodeList></span><span class="sxs-lookup"><span data-stu-id="92a82-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="92a82-169">現在のノードの操作</span><span class="sxs-lookup"><span data-stu-id="92a82-169">Working with the Current Node</span></span>

<span data-ttu-id="92a82-170">XAML ノード ループを使用するほとんどのシナリオは、ノードの読み取りだけを行うわけではありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="92a82-171">ほとんどのシナリオでは、現在のノードを処理し、 <xref:System.Xaml.XamlWriter>の実装に 1 回に 1 ノードずつ渡します。</span><span class="sxs-lookup"><span data-stu-id="92a82-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="92a82-172">一般的な読み込みパスりのシナリオでは、 <xref:System.Xaml.XamlXmlReader> は XAML ノード ストリームを生成します。XAML ノードは、ロジックと XAML スキーマ コンテキストに従って処理され、ノードは <xref:System.Xaml.XamlObjectWriter>に渡されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="92a82-173">続いて、生成されたオブジェクト グラフをアプリケーションまたはフレームワークに統合します。</span><span class="sxs-lookup"><span data-stu-id="92a82-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="92a82-174">一般的な保存パスのシナリオでは、 <xref:System.Xaml.XamlObjectReader> がオブジェクト グラフを読み取り、個々の XAML ノードが処理され、 <xref:System.Xaml.XamlXmlWriter> が XAML テキスト ファイルとしてシリアル化された結果を出力します。</span><span class="sxs-lookup"><span data-stu-id="92a82-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="92a82-175">重要なのは、パスとシナリオの両方で一度に1つの XAML ノードのみを操作することです。 xaml ノードは、XAML 型システムおよび the.NET XAML サービス Api によって定義された標準化された方法で処理できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="92a82-176">フレームとスコープ</span><span class="sxs-lookup"><span data-stu-id="92a82-176">Frames and Scope</span></span>

<span data-ttu-id="92a82-177">XAML ノード ループは、線形的な方法で XAML ノード ストリーム全体を通過します。</span><span class="sxs-lookup"><span data-stu-id="92a82-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="92a82-178">ノード ストリームは、オブジェクト、他のオブジェクトを含むメンバーなどを走査します。</span><span class="sxs-lookup"><span data-stu-id="92a82-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="92a82-179">フレームとスタックの概念を実装して XAML ノード ストリーム内のスコープを追跡すると役立つことがよくあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="92a82-180">ノード ストリームの使用中に積極的に調整する場合は、特に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="92a82-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="92a82-181">ノード ループのロジックの一部として実装するフレームとスタックのサポートでは、DOM の観点から構造を考える場合、XAML ノードの構造に下りる際に `StartObject` (または `GetObject`) と `EndObject` スコープをカウントすることがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="92a82-182">オブジェクトのノードの走査と入力</span><span class="sxs-lookup"><span data-stu-id="92a82-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="92a82-183">XAML リーダーによって開かれたときのノード ストリームの最初のノードは、ルート オブジェクトの開始オブジェクト ノードです。</span><span class="sxs-lookup"><span data-stu-id="92a82-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="92a82-184">定義上、このオブジェクトは常に 1 つのオブジェクト ノードで、ピアはありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="92a82-185">現実世界の XAML の例では、ルート オブジェクトがより多くのオブジェクトを保持する 1 つ以上のプロパティを持つように定義されます。これらのプロパティにはメンバー ノードがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="92a82-186">メンバー ノードには、1 つ以上のオブジェクト ノードがあるか、代わりに値ノードで終了することもあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="92a82-187">一般的に、ルート オブジェクトは XAML の名前のスコープを定義します。これは構文的に属性として XAML テキスト マークアップに割り当てられますが、XAML ノード ストリームの表現にある `Namescope` ノードの種類にマップされます。</span><span class="sxs-lookup"><span data-stu-id="92a82-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="92a82-188">次の XAML の例について考えてみます (これは、.NET の既存の型ではサポートされていない任意の XAML です)。</span><span class="sxs-lookup"><span data-stu-id="92a82-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="92a82-189">このオブジェクト モデルでは、 `FavorCollection` は `List<T>` の `Favor`であること、 `Balloon` と `NoiseMaker` は `Favor`への割り当てが可能であること、 `Balloon.Color` プロパティは `Color` オブジェクトに基づいていること (WPF が色を既知の色の名前として定義する方法に似ています)、および `Color` は属性の構文の型コンバーターをサポートすると想定します。</span><span class="sxs-lookup"><span data-stu-id="92a82-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="92a82-190">XAML マークアップ</span><span class="sxs-lookup"><span data-stu-id="92a82-190">XAML markup</span></span>|<span data-ttu-id="92a82-191">結果となる XAML ノード ストリーム</span><span class="sxs-lookup"><span data-stu-id="92a82-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="92a82-192">`Namespace` の `Party`</span><span class="sxs-lookup"><span data-stu-id="92a82-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="92a82-193">`StartObject` の `Party`</span><span class="sxs-lookup"><span data-stu-id="92a82-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="92a82-194">`StartMember` の `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="92a82-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="92a82-195">暗黙的な`StartObject` の `FavorCollection`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="92a82-196">暗黙的な`StartMember` 項目のプロパティの `FavorCollection` ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="92a82-197">`StartObject` の `Balloon`</span><span class="sxs-lookup"><span data-stu-id="92a82-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="92a82-198">`StartMember` の `Color`</span><span class="sxs-lookup"><span data-stu-id="92a82-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="92a82-199">属性値の文字列`Value` の `"Red"`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="92a82-200">`Color` の `EndMember`</span><span class="sxs-lookup"><span data-stu-id="92a82-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="92a82-201">`StartMember` の `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="92a82-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="92a82-202">属性値の文字列`Value` の `"True"`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="92a82-203">`HasHelium` の `EndMember`</span><span class="sxs-lookup"><span data-stu-id="92a82-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="92a82-204">`Balloon` の `EndObject`</span><span class="sxs-lookup"><span data-stu-id="92a82-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="92a82-205">`StartObject` の `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="92a82-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="92a82-206">`StartMember` の `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="92a82-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="92a82-207">初期化値の文字列`Value` の `"Loudest"`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="92a82-208">`EndMember` の `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="92a82-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="92a82-209">`NoiseMaker` の `EndObject`</span><span class="sxs-lookup"><span data-stu-id="92a82-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="92a82-210">暗黙的な`EndMember` 項目のプロパティの `FavorCollection` ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="92a82-211">暗黙的な`EndObject` の `FavorCollection`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="92a82-212">`Favors` の `EndMember`</span><span class="sxs-lookup"><span data-stu-id="92a82-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="92a82-213">`Party` の `EndObject`</span><span class="sxs-lookup"><span data-stu-id="92a82-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="92a82-214">XAML ノード ストリームでは、次の動作に依存することができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="92a82-215">`Namespace` ノードが存在する場合は、 `StartObject` で XAML 名前空間を宣言した `xmlns`の直前のストリームに追加されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="92a82-216">もう一度、XAML と使用例のノード ストリームがある上記の表をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="92a82-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="92a82-217">`StartObject` ノードと `Namespace` ノードがテキストのマークアップでそれらの宣言の位置とどのように入れ替えられているかに注意してください。</span><span class="sxs-lookup"><span data-stu-id="92a82-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="92a82-218">これは、ノード ストリームで、名前空間ノードが常に適用するノードの前に表示される動作の典型です。</span><span class="sxs-lookup"><span data-stu-id="92a82-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="92a82-219">この設計の目的は、名前空間情報は、オブジェクト ライターにとって重要であり、オブジェクト ライターが型のマッピングの実行を試みる前 (そうでなければオブジェクトを処理する前) に知らされる必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="92a82-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="92a82-220">ストリームで XAML 名前空間の情報をアプリケーションのスコープの前に配置すると、ノード ストリームを常に表示された順序で処理することが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="92a82-221">前述の考慮事項により、ノードをルートの `Namespace` からではなく最初から走査する場合、ほとんどの現実世界のマークアップのケースで最初に読み取る `StartObject` ノードは 1 つ以上になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="92a82-222">`StartObject` ノードの後には `StartMember`、 `Value`、またはすぐに `EndObject`が続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="92a82-223">別の `StartObject`がすぐに続くことはありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="92a82-224">`StartMember` の後には `StartObject`、 `Value`、またはすぐに `EndMember`が続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="92a82-225">新しい値をインスタンス化する `GetObject`ではなく、値が親オブジェクトの既存の値に由来すると想定されるメンバーの場合は、後に `StartObject` が続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="92a82-226">また、 `Namespace` ノードも後に続きます。このノードは今後の `StartObject`に適用されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="92a82-227">別の `StartMember`がすぐに続くことはありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="92a82-228">`Value` ノードは値自体を表します。 "EndValue" はありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="92a82-229">後には `EndMember`のみが続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="92a82-230">構築で使用される可能性があるオブジェクトの XAML 初期化テキストは、オブジェクト - 値構造の結果にはなりません。</span><span class="sxs-lookup"><span data-stu-id="92a82-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="92a82-231">代わりに、 `_Initialization` という名前のメンバーの専用のメンバー ノードが作成されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="92a82-232">そのメンバー ノードには、初期化値の文字列が含まれています。</span><span class="sxs-lookup"><span data-stu-id="92a82-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="92a82-233">存在する場合は、 `_Initialization` が常に最初の `StartMember`になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="92a82-234">一部の XAML サービス表記では、`_Initialization` が XAML 言語の XAML 名前スコープで修飾して、 `_Initialization` がバッキング タイプで定義されたプロパティでないことを明確にすることがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="92a82-235">メンバーと値の組み合わせは、値の属性設定を表します。</span><span class="sxs-lookup"><span data-stu-id="92a82-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="92a82-236">結局、この値の処理に関係する値コンバーターが使用されることがあり、値はプレーン文字列になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="92a82-237">ただし、これは XAML オブジェクト ライターがこのノード ストリームを処理するまで評価されません。</span><span class="sxs-lookup"><span data-stu-id="92a82-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="92a82-238">XAML オブジェクト ライターには、必要な XAML スキーマ コンテキスト、型システムのマッピング、および値の変換に必要なその他のサポートが用意されています。</span><span class="sxs-lookup"><span data-stu-id="92a82-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="92a82-239">`EndMember` ノードの後には、後続のメンバーとして `StartMember` ノード、またはメンバーの所有者として `EndObject` ノードが続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="92a82-240">`EndObject` ノードの後には、 `EndMember` ノードが続きます。</span><span class="sxs-lookup"><span data-stu-id="92a82-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="92a82-241">さらに、オブジェクトがコレクション アイテムのピアである場合は、 `StartObject` ノードが後に続くこともあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="92a82-242">または、 `Namespace` ノードが後に続きます。このノードは今後の `StartObject`に適用されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="92a82-243">ノード ストリーム全体を閉じるという独特なケースでは、ルートの `EndObject` の後には何も続きません。リーダーはファイルの終わりになり、 <xref:System.Xaml.XamlReader.Read%2A> は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="92a82-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="92a82-244">値コンバーターと XAML ノード ストリーム</span><span class="sxs-lookup"><span data-stu-id="92a82-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="92a82-245">値コンバーターとは、マークアップ拡張機能、型コンバーター (値のシリアライザーを含む)、または XAML 型システムを介して値コンバーターとして報告されている別の専用のクラスの一般用語です。</span><span class="sxs-lookup"><span data-stu-id="92a82-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="92a82-246">XAML ノード ストリームでは、型コンバーターの使用法と、マークアップ拡張機能の使用法では、表現が非常に異なります。</span><span class="sxs-lookup"><span data-stu-id="92a82-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="92a82-247">XAML ノード ストリームでの型コンバーター</span><span class="sxs-lookup"><span data-stu-id="92a82-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="92a82-248">最終的に型コンバーターの使用になる属性セットは、メンバーの値として XAML ノード ストリームで報告されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="92a82-249">XAML ノード ストリームは、型コンバーター インスタンス オブジェクトを生成してこれに値を渡そうとはしません。</span><span class="sxs-lookup"><span data-stu-id="92a82-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="92a82-250">型コンバーターの変換の実装を使用するには、XAML スキーマ コンテキストを呼び出して、型マッピングに使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="92a82-251">値の処理にどの型コンバーターのクラスを使用する必要があるかを決定する場合でも、XAML スキーマ コンテキストが間接的に必要になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="92a82-252">既定の XAML スキーマ コンテキストを使用する場合は、対象の情報は XAML 型システムから使用できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="92a82-253">XAML ライターへの接続の前に XAML ノード ストリーム レベルで型コンバーター クラスの情報が必要な場合、設定されているメンバーの <xref:System.Xaml.XamlMember> 情報から取得することができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="92a82-254">それ以外の場合、型コンバーターの入力は、xaml オブジェクトライターによるオブジェクトの作成など、型マッピングシステムと XAML スキーマコンテキストを必要とする操作の残りの部分が実行されるまで、純粋な値として XAML ノードストリームに保持される必要があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="92a82-255">たとえば、次のクラス定義の概要とそれに対する XAML の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="92a82-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="92a82-256">この使用法向けの XAML ノード ストリームのテキスト表現は、次のように表現できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="92a82-257">`StartObject` を表す <xref:System.Xaml.XamlType> と `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="92a82-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="92a82-258">`StartMember` を表す <xref:System.Xaml.XamlMember> と `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="92a82-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="92a82-259">テキスト文字列 "`Value` " がある`8x8`ノード</span><span class="sxs-lookup"><span data-stu-id="92a82-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="92a82-260">`EndMember` と一致する `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="92a82-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="92a82-261">`EndObject` と一致する `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="92a82-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="92a82-262">このノード ストリームには型コンバーター インスタンスがないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="92a82-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="92a82-263">ただし、 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> の <xref:System.Xaml.XamlMember> で `BoardSize`を呼び出して、型コンバーター情報を取得することができます。</span><span class="sxs-lookup"><span data-stu-id="92a82-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="92a82-264">有効な XAML スキーマ コンテキストがある場合は、 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>からインスタンスを取得することでコンバーターのメソッドを呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="92a82-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="92a82-265">XAML ノード ストリームのマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="92a82-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="92a82-266">マークアップ拡張機能の使用状況は、メンバー内のオブジェクト ノードとして XAML ノード ストリームで報告されます。ここで、オブジェクトはマークアップ拡張機能のインスタンスを表します。</span><span class="sxs-lookup"><span data-stu-id="92a82-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="92a82-267">そのため、マークアップ拡張機能の使用法は、型コンバーターの使用法より明示的にノード ストリームの表現で表され、より多くの情報を伝達できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="92a82-268"><xref:System.Xaml.XamlMember> の情報では、マークアップ拡張機能について何も述べることができませんでした。これは、使用法が状況に左右され、可能な各マークアップのケースで異なるためです。型コンバーターの場合のようには、使用法が型またはメンバーごとに専用かつ暗黙的なのではありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="92a82-269">オブジェクトのノードとしてのマークアップ拡張機能のノード ストリームの表現は、マークアップ拡張機能の使用法が XAML テキスト マークアップ内の属性の形式である場合でも該当します (多くの場合該当します)。</span><span class="sxs-lookup"><span data-stu-id="92a82-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="92a82-270">明示的なオブジェクトの要素の形式を使用するマークアップ拡張機能の使用法は同じように扱われます。</span><span class="sxs-lookup"><span data-stu-id="92a82-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="92a82-271">マークアップ拡張機能のオブジェクト ノード内には、そのマークアップ拡張機能のメンバーが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="92a82-272">XAML ノード ストリームの表現では、位置指定のパラメーターの使用法か、明示的な名前付きパラメーターの使用法によって、そのマークアップ拡張機能の使用法が維持されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="92a82-273">位置指定のパラメーターの使用法の場合、XAML ノード ストリームには、使用状況を記録する、XAML 言語で定義されたプロパティ `_PositionalParameters` が含まれます。</span><span class="sxs-lookup"><span data-stu-id="92a82-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="92a82-274">このプロパティは、 <xref:System.Collections.Generic.List%601> 制約が付いたジェネリック <xref:System.Object> です。</span><span class="sxs-lookup"><span data-stu-id="92a82-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="92a82-275">制約は、オブジェクトであり、文字列ではありません。位置指定のパラメーターの使用法では、場合によって、そのパラメーターの中に入れ子になったマークアップ拡張機能の使用法が含まれている可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="92a82-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="92a82-276">使用法から位置指定のパラメーターにアクセスするため、リストを反復処理してから、個々のリストの値にインデクサーを使用することがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="92a82-277">名前付きパラメーターの使用法では、名前付きの各パラメーターは、ノード ストリームでその名前のメンバー ノードとして表されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="92a82-278">メンバー値は必ずしも文字列とは限りません。入れ子になったマークアップ拡張機能の使用の可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="92a82-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="92a82-279">`ProvideValue` はマークアップ拡張機能から、まだ呼び出されていません。</span><span class="sxs-lookup"><span data-stu-id="92a82-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="92a82-280">ただし、ノード ストリームで `WriteEndObject` を確認する際、マークアップ拡張機能ノードで呼び出されるように XAML リーダーと XAML ライターを接続する場合はこれが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="92a82-281">このため、通常は、読み込みパスでオブジェクト グラフを形成するために使用するのと同じ XAML スキーマのコンテキストが使用できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="92a82-282">それ以外の場合、すべてのマークアップ拡張機能の `ProvideValue` は、期待されるサービスが使用可能でないため、ここで例外をスローする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="92a82-283">XAML ノード ストリームにおける XAML および XML 言語で定義されたメンバー</span><span class="sxs-lookup"><span data-stu-id="92a82-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="92a82-284">明示的な <xref:System.Xaml.XamlMember> の検索または構築を介してではなく、XAML リーダーの解釈と規約のため、特定のメンバーが XAML ノード ストリームに導入されています。</span><span class="sxs-lookup"><span data-stu-id="92a82-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="92a82-285">多くの場合、これらのメンバーは XAML ディレクティブです。</span><span class="sxs-lookup"><span data-stu-id="92a82-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="92a82-286">場合によっては、XAML ノード ストリームにディレクティブを導入する XAML の読み取りの動作になります。</span><span class="sxs-lookup"><span data-stu-id="92a82-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="92a82-287">つまり、元の入力 XAML テキストでは、メンバーディレクティブが明示的に指定されていませんでしたが、xaml リーダーは、構造の XAML 規則を満たすためにディレクティブを挿入し、情報が失われる前に XAML ノードストリームの情報を報告します。</span><span class="sxs-lookup"><span data-stu-id="92a82-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="92a82-288">次の一覧は、XAML リーダーでディレクティブの XAML メンバーノードが導入される可能性があるすべてのケースと、.NET XAML サービスの実装でそのメンバーノードがどのように識別されるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="92a82-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="92a82-289">**オブジェクト ノードの初期化テキスト:** このメンバー ノードの名前は `_Initialization`です。この名前は XAML ディレクティブを表し、XAML 言語の XAML 名前空間で定義されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="92a82-290">その静的なエンティティは <xref:System.Xaml.XamlLanguage.Initialization%2A>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="92a82-291">**マークアップ拡張機能の位置指定パラメーター:** このメンバー ノードの名前は `_PositionalParameters`です。この名前は、XAML 言語の XAML 名前空間で定義されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="92a82-292">それには常にオブジェクトのジェネリック リストが含まれ、それぞれが入力 XAML で指定される `,` 区切り文字で分割して事前に分離された位置指定パラメーターになっています。</span><span class="sxs-lookup"><span data-stu-id="92a82-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="92a82-293"><xref:System.Xaml.XamlLanguage.PositionalParameters%2A>から、位置指定パラメーター ディレクティブの静的なエンティティを取得できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="92a82-294">**不明なコンテンツ:** このメンバー ノードの名前は `_UnknownContent`です。</span><span class="sxs-lookup"><span data-stu-id="92a82-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="92a82-295">厳密に言うと、これは <xref:System.Xaml.XamlDirective>で、XAML 言語の XAML 名前空間で定義されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="92a82-296">このディレクティブは、XAML オブジェクト要素にソース XAML のコンテンツが含まれている場合は sentinel として使用されますが、現在使用できる XAML スキーマ コンテキストで決定できるコンテンツのプロパティはありません。</span><span class="sxs-lookup"><span data-stu-id="92a82-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="92a82-297">`_UnknownContent`という名前のメンバーを確認すると、XAML ノード ストリームでこのケースを検出できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="92a82-298">読み込みパスの XAML ノード ストリームでその他の処理が行われない場合、いずれかのオブジェクトで <xref:System.Xaml.XamlObjectWriter> のメンバーが検出されると、試行した `WriteEndObject` で既定の `_UnknownContent` がスローされます。</span><span class="sxs-lookup"><span data-stu-id="92a82-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="92a82-299">既定の <xref:System.Xaml.XamlXmlWriter> はスローされず、メンバーを暗黙の型として処理します。</span><span class="sxs-lookup"><span data-stu-id="92a82-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="92a82-300">`_UnknownContent` の静的なエンティティは <xref:System.Xaml.XamlLanguage.UnknownContent%2A>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="92a82-301">**コレクションのコレクションプロパティ:** XAML に使用されるコレクションクラスのバッキング CLR 型には、コレクション項目を保持する専用の名前付きプロパティがありますが、このプロパティは、バッキング型の解決の前に XAML 型システムで認識されません。</span><span class="sxs-lookup"><span data-stu-id="92a82-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="92a82-302">代わりに、XAML ノード ストリームでは、コレクションの XAML 型のメンバーとして `Items` プレース ホルダーを導入します。</span><span class="sxs-lookup"><span data-stu-id="92a82-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="92a82-303">.NET XAML サービスの実装では、このディレクティブまたはノードストリーム内のメンバーの名前は `_Items` です。</span><span class="sxs-lookup"><span data-stu-id="92a82-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="92a82-304">このディレクティブの定数は <xref:System.Xaml.XamlLanguage.Items%2A>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="92a82-305">XAML ノードストリームには、バッキング型の解決と XAML スキーマコンテキストに基づいて解析できない項目を含む Items プロパティが含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="92a82-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="92a82-306">たとえば、次のように入力します。</span><span class="sxs-lookup"><span data-stu-id="92a82-306">For example,</span></span>

- <span data-ttu-id="92a82-307">**XML で定義されたメンバー:** XML 定義の、、およびの各 `xml:base` `xml:lang` `xml:space` メンバーは、 `base` `lang` `space` .net xaml サービスの実装では、、およびという名前の XAML ディレクティブとして報告されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="92a82-308">これらの名前空間は、XML 名前空間 `http://www.w3.org/XML/1998/namespace`です。</span><span class="sxs-lookup"><span data-stu-id="92a82-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="92a82-309">これらのそれぞれの定数は <xref:System.Xaml.XamlLanguage>から取得できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="92a82-310">ノードの順序</span><span class="sxs-lookup"><span data-stu-id="92a82-310">Node Order</span></span>

<span data-ttu-id="92a82-311">場合によって <xref:System.Xaml.XamlXmlReader> は、マークアップに表示する場合、または XML として処理される場合に、ノードの表示順序と比較して、XAML ノード ストリームの XAML ノードの順序を変更します。</span><span class="sxs-lookup"><span data-stu-id="92a82-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="92a82-312">この変更は、 <xref:System.Xaml.XamlObjectWriter> が順方向のみにノード ストリームを処理できるようにノードの順序を指定するために行います。</span><span class="sxs-lookup"><span data-stu-id="92a82-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="92a82-313">.NET XAML サービスでは、xaml リーダーは、ノードストリームの XAML オブジェクトライターのコンシューマーのパフォーマンスの最適化として、このタスクを XAML ライターに任せるのではなく、ノードを並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="92a82-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="92a82-314">特定のディレクティブは、特にオブジェクト要素からオブジェクトを作成するために、より多くの情報を提供することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="92a82-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="92a82-315">これらのディレクティブは `Initialization`、 `PositionalParameters`、 `TypeArguments`、 `FactoryMethod`、 `Arguments`です。</span><span class="sxs-lookup"><span data-stu-id="92a82-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="92a82-316">.NET XAML サービスの XAML リーダー `StartObject` は、次のセクションで説明されている理由により、これらのディレクティブを、オブジェクトのに続くノードストリームの最初のメンバーとして配置しようとします。</span><span class="sxs-lookup"><span data-stu-id="92a82-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="92a82-317">XamlObjectWriter の動作とノードの順序</span><span class="sxs-lookup"><span data-stu-id="92a82-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="92a82-318">`StartObject` に対する <xref:System.Xaml.XamlObjectWriter> は、すぐにオブジェクト インスタンスを作成するための XAML オブジェクト ライターへのシグナルであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="92a82-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="92a82-319">XAML には、追加の入力を使用してオブジェクトを初期化できるようにするいくつかの言語機能が用意されています。また、パラメーターなしのコンストラクターを呼び出して初期オブジェクトを生成し、その後でプロパティを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="92a82-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="92a82-320">これらの機能には、 <xref:System.Windows.Markup.XamlDeferLoadAttribute>、初期化のテキスト、 [x:TypeArguments](xtypearguments-directive.md)、マークアップ拡張機能の位置指定パラメーター、工場出荷時のメソッド、および関連する [x:Arguments](xarguments-directive.md) ノード (XAML 2009) などがあります。</span><span class="sxs-lookup"><span data-stu-id="92a82-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="92a82-321">これらの各ケースは、実際のオブジェクトの構築を遅らせます。ノードストリームが並べ替えられるため、XAML オブジェクトライターは、明示的には、そのオブジェクト型の構築ディレクティブではない開始メンバーが検出されたときに、実際にインスタンスを構築する動作に依存できます。</span><span class="sxs-lookup"><span data-stu-id="92a82-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="92a82-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="92a82-322">GetObject</span></span>

<span data-ttu-id="92a82-323">`GetObject` は、XAML オブジェクト ライターが新しいオブジェクトを構築するのではなく、オブジェクトの包含プロパティの値を取得する必要がある XAML ノードを表します。</span><span class="sxs-lookup"><span data-stu-id="92a82-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="92a82-324">XAML ノード ストリームで `GetObject` ノードに発生する一般的なケースは、コレクション オブジェクトまたは辞書オブジェクトで、包含するプロパティがバッキング型のオブジェクト モデルで意図的に読み取り専用になる場合です。</span><span class="sxs-lookup"><span data-stu-id="92a82-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="92a82-325">このシナリオでは、コレクションまたは辞書は、多くの場合は所有する型の初期化ロジックによって作成および (通常は空に) 初期化されます。</span><span class="sxs-lookup"><span data-stu-id="92a82-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="92a82-326">関連項目</span><span class="sxs-lookup"><span data-stu-id="92a82-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="92a82-327">XAML サービス</span><span class="sxs-lookup"><span data-stu-id="92a82-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="92a82-328">XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="92a82-328">XAML Namespaces</span></span>](namespaces.md)
