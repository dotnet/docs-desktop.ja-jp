---
title: 依存関係プロパティのコールバックと検証
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: c5f7439753037aeb5c2ff558da63e063ad65a5e1
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96982328"
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="582a4-102">依存関係プロパティのコールバックと検証</span><span class="sxs-lookup"><span data-stu-id="582a4-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="582a4-103">このトピックでは、検証による判定、プロパティの有効値が変更されたときに呼び出されるコールバック、値の決定への外部的影響のオーバーライドなど、プロパティ関連機能の代替カスタム実装を使用して依存関係プロパティを作成する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="582a4-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="582a4-104">また、これらの手法を用いてプロパティ システムの既定の動作を拡張することが適切であるシナリオについても説明します。</span><span class="sxs-lookup"><span data-stu-id="582a4-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="582a4-105">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="582a4-105">Prerequisites</span></span>  
 <span data-ttu-id="582a4-106">このトピックでは、依存関係プロパティの実装の基本シナリオとカスタム依存関係プロパティへのメタデータの適用方法を理解していることを前提とします。</span><span class="sxs-lookup"><span data-stu-id="582a4-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="582a4-107">詳細については、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」および「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="582a4-107">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>
## <a name="validation-callbacks"></a><span data-ttu-id="582a4-108">検証コールバック</span><span class="sxs-lookup"><span data-stu-id="582a4-108">Validation Callbacks</span></span>  
 <span data-ttu-id="582a4-109">検証コールバックは、最初の登録時に依存関係プロパティに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="582a4-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="582a4-110">検証コールバックは、プロパティ メタデータの一部ではなく、<xref:System.Windows.DependencyProperty.Register%2A> メソッドの直接入力です。</span><span class="sxs-lookup"><span data-stu-id="582a4-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="582a4-111">したがって、依存関係プロパティの検証コールバックを作成した後で、その検証コールバックを新しい実装でオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="582a4-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="582a4-112">検証コールバックは、オブジェクト値を受け取るように実装されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="582a4-113">指定された値がプロパティに対して有効である場合は `true` を、有効でない場合は `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="582a4-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="582a4-114">プロパティの型はプロパティ システムに登録済みの適切な型であると想定されます。したがって、通常の場合、コールバック内での型チェックは行われません。</span><span class="sxs-lookup"><span data-stu-id="582a4-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="582a4-115">検証コールバックは、プロパティ システムが実行するさまざまな操作で使用されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="582a4-116">たとえば、最初に型を既定値で初期化したり、<xref:System.Windows.DependencyObject.SetValue%2A> を呼び出してプログラムで値を変更したり、指定された新しい既定値でメタデータをオーバーライドする場合などに使用されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="582a4-117">これらの操作で呼び出された検証コールバックが `false` を返す場合、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="582a4-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="582a4-118">アプリケーションの作成者はこれらの例外を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="582a4-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="582a4-119">検証コールバックは、列挙値の検証や、プロパティの測定値がゼロ以上に設定されている場合に integer 型または double 型の値を制限するときによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="582a4-120">検証コールバックは、インスタンスではなくクラスを検証するためのものです。</span><span class="sxs-lookup"><span data-stu-id="582a4-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="582a4-121">コールバックのパラメーターでは、検証対象のプロパティが設定されている特定の <xref:System.Windows.DependencyObject> には通知されません。</span><span class="sxs-lookup"><span data-stu-id="582a4-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="582a4-122">したがって、検証コールバックを使用して、プロパティ値に影響を及ぼす可能性がある "依存関係" (インスタンス固有のプロパティ値が他のインスタンス固有のプロパティ値や実行時の状態などの要因に依存する関係) を強制することはできません。</span><span class="sxs-lookup"><span data-stu-id="582a4-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="582a4-123">非常に簡単な検証コールバック シナリオのコード例を次に示します。この例では、<xref:System.Double> プリミティブ型として型指定されているプロパティが <xref:System.Double.PositiveInfinity> または <xref:System.Double.NegativeInfinity> ではないことを検証します。</span><span class="sxs-lookup"><span data-stu-id="582a4-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="582a4-124">強制値コールバックとプロパティ変更イベント</span><span class="sxs-lookup"><span data-stu-id="582a4-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="582a4-125">依存関係プロパティの値が変更されるたびにプロパティ システムによって呼び出される <xref:System.Windows.PropertyChangedCallback> の実装と同様に、強制値コールバックではプロパティに対して特定の <xref:System.Windows.DependencyObject> のインスタンスが渡されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="582a4-126">これら 2 つのコールバックを組み合わせて使用すると、あるプロパティが変更されたときに他のプロパティに自動的に強制または再評価が適用される一連のプロパティを要素に作成することができます。</span><span class="sxs-lookup"><span data-stu-id="582a4-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="582a4-127">依存関係プロパティ間の関連は、最小値、最大値、および実際の値 (または現在の値) を表す 3 つ目のプロパティが要素に含まれる場合において、ユーザー インターフェイスによって駆動されるプロパティがあるときによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="582a4-128">ここで、最大値が現在の値より小さい値に調整された場合、現在の値を新しい最大値以下の値に強制する必要があります。現在の値と最小値についても同様の関係が成り立ちます。</span><span class="sxs-lookup"><span data-stu-id="582a4-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="582a4-129">次の、3 つの依存関係プロパティの 1 つを示す非常に簡単なコード例は、こうした関係を表しています。</span><span class="sxs-lookup"><span data-stu-id="582a4-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="582a4-130">この例は、関連する \*Reading プロパティ (Min、Max、Current) のうちの 1 つである `CurrentReading` プロパティの登録方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="582a4-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related \*Reading properties is registered.</span></span> <span data-ttu-id="582a4-131">ここでは、前のセクションで説明した検証を使用しています。</span><span class="sxs-lookup"><span data-stu-id="582a4-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="582a4-132">Current のプロパティ変更コールバックを使用して、他の依存関係プロパティに対して登録されている強制値コールバックを明示的に呼び出すことにより、変更を他のプロパティに伝播します。</span><span class="sxs-lookup"><span data-stu-id="582a4-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="582a4-133">強制値コールバックは、Current プロパティが依存している可能性があるプロパティの値を検証し、必要に応じて現在の値を強制的に指定します。</span><span class="sxs-lookup"><span data-stu-id="582a4-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> <span data-ttu-id="582a4-134">プロパティの既定値は強制的に指定されません。</span><span class="sxs-lookup"><span data-stu-id="582a4-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="582a4-135">プロパティ値で初期既定値がまだ保持されている場合、または <xref:System.Windows.DependencyObject.ClearValue%2A> で他の値が消去された場合、プロパティ値が既定値に等しくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="582a4-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="582a4-136">強制値コールバックとプロパティ変更コールバックはプロパティ メタデータの一部です。</span><span class="sxs-lookup"><span data-stu-id="582a4-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="582a4-137">したがって、特定の依存関係プロパティを所有する型から派生させた型に存在するその特定の依存関係プロパティのコールバックは、派生させた型でプロパティのメタデータをオーバーライドすることで変更できます。</span><span class="sxs-lookup"><span data-stu-id="582a4-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="582a4-138">高度な強制とコールバック シナリオ</span><span class="sxs-lookup"><span data-stu-id="582a4-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="582a4-139">制約と目的の値</span><span class="sxs-lookup"><span data-stu-id="582a4-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="582a4-140">プロパティ システムによって <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> コールバックが使用され、開発者が宣言したロジックに従って値が強制的に指定されますが、ローカルに設定されたプロパティの強制された値では、"目的の値" が内部的にまだ保持されています。</span><span class="sxs-lookup"><span data-stu-id="582a4-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="582a4-141">制約がアプリケーションの有効期間内に動的に変更される可能性があるプロパティ値に基づいている場合、強制の制約も動的に変更されます。そして、制約されているプロパティは、指定された新しい制約の下で、その値を目的の値にできる限り近づけることができます。</span><span class="sxs-lookup"><span data-stu-id="582a4-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="582a4-142">制約がすべて解除された場合、値は目的の値になります。</span><span class="sxs-lookup"><span data-stu-id="582a4-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="582a4-143">相互に循環的に依存する複数のプロパティを使用している場合、非常に複雑な依存関係シナリオを導入することができます。</span><span class="sxs-lookup"><span data-stu-id="582a4-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="582a4-144">たとえば、Min、Max、Current のシナリオでは、Minimum と Maximum をユーザー設定可能なプロパティにすることができます。</span><span class="sxs-lookup"><span data-stu-id="582a4-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="582a4-145">その場合、Maximum が常に Minimum より大きくなり、Minimum が常に Maximum より小さくなるように強制する必要があります。</span><span class="sxs-lookup"><span data-stu-id="582a4-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="582a4-146">ただし、この強制を有効にし、Maximum が Minimum に強制された場合、Current が未設定の状態になります。なぜなら、Currenct は Maximum と Minimum の両方に依存し、両者の値の間の範囲内 (この場合はゼロ) に制約されるからです。</span><span class="sxs-lookup"><span data-stu-id="582a4-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="582a4-147">その後、Maximum または Minimum が調整された場合、Current はいずれかの値を "追跡" すると考えられます。なぜなら、Current の目的の値が依然として保持されており、制約が緩和されると Current が目的の値に到達しようとするからです。</span><span class="sxs-lookup"><span data-stu-id="582a4-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="582a4-148">依存関係が複雑でも技術的には問題はありません。ただし、多数の再評価が必要になる場合、パフォーマンスが若干低下することがあります。また、UI に直接影響する場合は、ユーザーの混乱につながることもあります。</span><span class="sxs-lookup"><span data-stu-id="582a4-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="582a4-149">プロパティ変更コールバックおよび強制値コールバックについては注意が必要です。試行中の強制ができる限り明確に処理されること、およびその制約が "過剰制約" ではないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="582a4-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="582a4-150">CoerceValue を使用した値変更の取り消し</span><span class="sxs-lookup"><span data-stu-id="582a4-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="582a4-151">プロパティ システムでは、<xref:System.Windows.DependencyProperty.UnsetValue> 値を返すすべての <xref:System.Windows.CoerceValueCallback> が特殊なケースとして処理されます。</span><span class="sxs-lookup"><span data-stu-id="582a4-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="582a4-152">この特殊なケースは、<xref:System.Windows.CoerceValueCallback> 呼び出しの原因となったプロパティの変更がプロパティ システムによって拒否され、代わりにプロパティの直前の値がプロパティ システムによって報告されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="582a4-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="582a4-153">このメカニズムは、非同期に開始されたプロパティの変更が現在のオブジェクトの状態に対して依然として有効であるかどうかをチェックし、有効でない場合はその変更を抑制する場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="582a4-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="582a4-154">考えられるもう 1 つのシナリオとして、プロパティ値の決定におけるどの構成要素が報告されるプロパティ値を決定するかに応じて値を選択的に抑制することもできます。</span><span class="sxs-lookup"><span data-stu-id="582a4-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="582a4-155">これを行うには、コールバックで渡された <xref:System.Windows.DependencyProperty> とプロパティ識別子を <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A> への入力として使用し、次に <xref:System.Windows.ValueSource> を処理します。</span><span class="sxs-lookup"><span data-stu-id="582a4-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="582a4-156">関連項目</span><span class="sxs-lookup"><span data-stu-id="582a4-156">See also</span></span>

- [<span data-ttu-id="582a4-157">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="582a4-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="582a4-158">依存関係プロパティのメタデータ</span><span class="sxs-lookup"><span data-stu-id="582a4-158">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="582a4-159">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="582a4-159">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
