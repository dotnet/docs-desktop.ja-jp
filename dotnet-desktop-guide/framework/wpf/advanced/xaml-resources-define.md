---
title: XAML リソースの定義
description: .NET Framework 用の WPF の XAML リソースについて説明します。 XAML リソースの種類を理解し、XAML リソースの定義方法を学びます。
author: adegeo
ms.author: adegeo
ms.date: 12/03/2020
ms.topic: overview
ms.openlocfilehash: 4c203fab7381e993ebc38a595e9622a89cd66d4f
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96983368"
---
# <a name="overview-of-xaml-resources"></a><span data-ttu-id="0768b-104">XAML リソースの概要</span><span class="sxs-lookup"><span data-stu-id="0768b-104">Overview of XAML resources</span></span>

<span data-ttu-id="0768b-105">リソースは、アプリ内のさまざまな場所で再利用できるオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="0768b-105">A resource is an object that can be reused in different places in your app.</span></span> <span data-ttu-id="0768b-106">リソースの例として、ブラシやスタイルがあります。</span><span class="sxs-lookup"><span data-stu-id="0768b-106">Examples of resources include brushes and styles.</span></span> <span data-ttu-id="0768b-107">この概要では、Extensible Application Markup Language (XAML) でのリソースの使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="0768b-107">This overview describes how to use resources in Extensible Application Markup Language (XAML).</span></span> <span data-ttu-id="0768b-108">また、コードを使用して、リソースを作成してアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="0768b-108">You can also create and access resources by using code.</span></span>

> [!NOTE]
> <span data-ttu-id="0768b-109">この記事で説明する XAML リソースは、 "*アプリ リソース*" とは異なります。アプリ リソースは一般に、コンテンツ、データ、埋め込みファイルなど、アプリに追加されるファイルです。</span><span class="sxs-lookup"><span data-stu-id="0768b-109">XAML resources described in this article are different from *app resources* which are generally files added to an app, such as content, data, or embedded files.</span></span>

## <a name="using-resources-in-xaml"></a><span data-ttu-id="0768b-110">XAML でのリソースの使用</span><span class="sxs-lookup"><span data-stu-id="0768b-110">Using resources in XAML</span></span>

<span data-ttu-id="0768b-111">次の例では、ページのルート要素のリソースとして <xref:System.Windows.Media.SolidColorBrush> を定義します。</span><span class="sxs-lookup"><span data-stu-id="0768b-111">The following example defines a <xref:System.Windows.Media.SolidColorBrush> as a resource on the root element of a page.</span></span> <span data-ttu-id="0768b-112">この例では、次にそのリソースを参照し、それを使用して、<xref:System.Windows.Shapes.Ellipse>、<xref:System.Windows.Controls.TextBlock>、<xref:System.Windows.Controls.Button> など、いくつかの子要素のプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="0768b-112">The example then references the resource and uses it to set properties of several child elements, including an <xref:System.Windows.Shapes.Ellipse>, a <xref:System.Windows.Controls.TextBlock>, and a <xref:System.Windows.Controls.Button>.</span></span>

[!code-xaml[FEResourceSH_snip#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xaml)]

<span data-ttu-id="0768b-113">すべてのフレームワーク レベルの要素 (<xref:System.Windows.FrameworkElement> や <xref:System.Windows.FrameworkContentElement>) には、定義されたリソースを含む <xref:System.Windows.ResourceDictionary> 型の <xref:System.Windows.FrameworkElement.Resources%2A> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="0768b-113">Every framework-level element (<xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>) has a <xref:System.Windows.FrameworkElement.Resources%2A> property, which is a <xref:System.Windows.ResourceDictionary> type that contains defined resources.</span></span> <span data-ttu-id="0768b-114">リソースは、<xref:System.Windows.Controls.Button> など、任意の要素に定義できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-114">You can define resources on any element, such as a <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="0768b-115">ただし、ほとんどの場合、リソースはルート要素 (例では <xref:System.Windows.Controls.Page>) に定義されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-115">However, resources are most often defined on the root element, which is <xref:System.Windows.Controls.Page> in the example.</span></span>

<span data-ttu-id="0768b-116">リソース ディクショナリ内の各リソースには、一意のキーが必要です。</span><span class="sxs-lookup"><span data-stu-id="0768b-116">Each resource in a resource dictionary must have a unique key.</span></span> <span data-ttu-id="0768b-117">マークアップでリソースを定義する場合は、[x:Key ディレクティブ](../../../xaml-services/xkey-directive.md)を使用して一意のキーを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="0768b-117">When you define resources in markup, you assign the unique key through the [x:Key Directive](../../../xaml-services/xkey-directive.md).</span></span> <span data-ttu-id="0768b-118">通常、キーは文字列です。ただし、適切なマークアップ拡張機能を使用して、他のオブジェクトの型に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="0768b-118">Typically, the key is a string; however, you can also set it to other object types by using the appropriate markup extensions.</span></span> <span data-ttu-id="0768b-119">リソースの文字列以外のキーは、WPF の特定の機能領域、特に、スタイル、コンポーネント リソース、データ スタイルに使用されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-119">Non-string keys for resources are used by certain feature areas in WPF, notably for styles, component resources, and data styling.</span></span>

<span data-ttu-id="0768b-120">定義されたリソースは、リソースのキー名を指定するリソース マークアップ拡張構文で使用できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-120">You can use a defined resource with the resource markup extension syntax that specifies the key name of the resource.</span></span> <span data-ttu-id="0768b-121">たとえば、リソースを別の要素のプロパティの値として使用します。</span><span class="sxs-lookup"><span data-stu-id="0768b-121">For example, use the resource as the value of a property on another element.</span></span>

[!code-xaml[FEResourceSH_snip#KeyNameUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#keynameusage)]

<span data-ttu-id="0768b-122">上記の例では、XAML ローダーで <xref:System.Windows.Controls.Button> の <xref:System.Windows.Controls.Control.Background%2A> プロパティの値 `{StaticResource MyBrush}` が処理されるときに、リソース検索ロジックではまず、<xref:System.Windows.Controls.Button> 要素のリソース ディクショナリが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-122">In the preceding example, when the XAML loader processes the value `{StaticResource MyBrush}` for the <xref:System.Windows.Controls.Control.Background%2A> property on <xref:System.Windows.Controls.Button>, the resource lookup logic first checks the resource dictionary for the <xref:System.Windows.Controls.Button> element.</span></span> <span data-ttu-id="0768b-123"><xref:System.Windows.Controls.Button> にリソース キー `MyBrush` の定義がない場合 (この例では定義がありません。そのリソース コレクションは空です)、検索では次に <xref:System.Windows.Controls.Button> の親要素 (<xref:System.Windows.Controls.Page>) が確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-123">If <xref:System.Windows.Controls.Button> doesn't have a definition of the resource key `MyBrush` (in that example it doesn't; its resource collection is empty), the lookup next checks the parent element of <xref:System.Windows.Controls.Button>, which is <xref:System.Windows.Controls.Page>.</span></span> <span data-ttu-id="0768b-124"><xref:System.Windows.Controls.Page> ルート要素にリソースを定義すると、<xref:System.Windows.Controls.Page> の論理ツリー内のすべての要素がそれにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0768b-124">If you define a resource on the <xref:System.Windows.Controls.Page> root element, all the elements in the logical tree of the <xref:System.Windows.Controls.Page> can access it.</span></span> <span data-ttu-id="0768b-125">さらに、同じリソースを再利用して、そのリソースが表すものと同じ型を受け入れるプロパティの値を設定できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-125">And you can reuse the same resource for setting the value of any property that accepts the same type that the resource represents.</span></span> <span data-ttu-id="0768b-126">前の例では、同じ `MyBrush` リソースで 2 つの異なるプロパティ (<xref:System.Windows.Controls.Button> の <xref:System.Windows.Controls.Control.Background%2A> と、<xref:System.Windows.Shapes.Rectangle> の <xref:System.Windows.Shapes.Shape.Fill%2A>) が設定されています。</span><span class="sxs-lookup"><span data-stu-id="0768b-126">In the previous example, the same `MyBrush` resource sets two different properties: the <xref:System.Windows.Controls.Control.Background%2A> of a <xref:System.Windows.Controls.Button>, and the <xref:System.Windows.Shapes.Shape.Fill%2A> of a <xref:System.Windows.Shapes.Rectangle>.</span></span>

## <a name="static-and-dynamic-resources"></a><span data-ttu-id="0768b-127">静的および動的なリソース</span><span class="sxs-lookup"><span data-stu-id="0768b-127">Static and dynamic resources</span></span>

<span data-ttu-id="0768b-128">リソースは、静的または動的として参照できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-128">A resource can be referenced as either static or dynamic.</span></span> <span data-ttu-id="0768b-129">参照は、[StaticResource のマークアップ拡張機能](staticresource-markup-extension.md)または [DynamicResource のマークアップ拡張機能](dynamicresource-markup-extension.md)を使用して作成します。</span><span class="sxs-lookup"><span data-stu-id="0768b-129">References are created by using either the [StaticResource Markup Extension](staticresource-markup-extension.md) or the [DynamicResource Markup Extension](dynamicresource-markup-extension.md).</span></span> <span data-ttu-id="0768b-130">マークアップ拡張機能は XAML の機能であり、マークアップ拡張機能が属性文字列を処理し、オブジェクトを XAML ローダーに返すことで、オブジェクト参照を指定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="0768b-130">A markup extension is a XAML feature that lets you specify an object reference by having the markup extension process the attribute string and return the object to a XAML loader.</span></span> <span data-ttu-id="0768b-131">マークアップ拡張機能の動作の詳細については、 「[マークアップ拡張機能と WPF XAML](markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-131">For more information about markup extension behavior, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>

<span data-ttu-id="0768b-132">マークアップ拡張機能を使用する場合、通常は、その特定のマークアップ拡張機能によって処理される 1 つ以上のパラメーターを文字列形式で指定します。</span><span class="sxs-lookup"><span data-stu-id="0768b-132">When you use a markup extension, you typically provide one or more parameters in string form that are processed by that particular markup extension.</span></span> <span data-ttu-id="0768b-133">[StaticResource のマークアップ拡張機能](staticresource-markup-extension.md)では、使用可能なすべてのリソース ディクショナリでそのキーの値を検索することでキーが処理されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-133">The [StaticResource Markup Extension](staticresource-markup-extension.md) processes a key by looking up the value for that key in all available resource dictionaries.</span></span> <span data-ttu-id="0768b-134">処理は読み込み中に行われます。これは、読み込みプロセスでプロパティ値を割り当てる必要がある場合です。</span><span class="sxs-lookup"><span data-stu-id="0768b-134">Processing happens during load, which is when the loading process needs to assign the property value.</span></span> <span data-ttu-id="0768b-135">[DynamicResource のマークアップ拡張機能](dynamicresource-markup-extension.md)では、それに代わり、式を作成してキーが処理されます。この式は、アプリが実行される時点までは未評価のままであり、その時点で式が評価され、値が提供されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-135">The [DynamicResource Markup Extension](dynamicresource-markup-extension.md) instead processes a key by creating an expression, and that expression remains unevaluated until the app runs, at which time the expression is evaluated and provides a value.</span></span>

<span data-ttu-id="0768b-136">リソースを参照する場合、静的リソース参照と動的リソース参照のどちらを使用するかに対し、次の考慮事項が影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-136">When you reference a resource, the following considerations can influence whether you use a static resource reference or a dynamic resource reference:</span></span>

- <span data-ttu-id="0768b-137">アプリ用リソースの作成方法の全体的な設計 (ページ単位、アプリ内、Loose XAML で、またはリソースのみのアセンブリで) を決定する際は、次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-137">When determining the overall design of how you create the resources for your app (per page, in the app, in loose XAML, or in a resource-only assembly), consider the following:</span></span>

- <span data-ttu-id="0768b-138">アプリの機能。</span><span class="sxs-lookup"><span data-stu-id="0768b-138">The app's functionality.</span></span> <span data-ttu-id="0768b-139">リソースをリアルタイムで更新することは、アプリの要件に含まれていますか。</span><span class="sxs-lookup"><span data-stu-id="0768b-139">Are updating resources in real-time part of your app requirements?</span></span>
- <span data-ttu-id="0768b-140">そのリソース参照の種類の、それぞれの検索動作。</span><span class="sxs-lookup"><span data-stu-id="0768b-140">The respective lookup behavior of that resource reference type.</span></span>
- <span data-ttu-id="0768b-141">特定のプロパティまたはリソースの種類と、それらの種類のネイティブ動作。</span><span class="sxs-lookup"><span data-stu-id="0768b-141">The particular property or resource type, and the native behavior of those types.</span></span>

## <a name="static-resources"></a><span data-ttu-id="0768b-142">静的リソース</span><span class="sxs-lookup"><span data-stu-id="0768b-142">Static resources</span></span>

<span data-ttu-id="0768b-143">静的リソース参照は、次のような状況に最適です。</span><span class="sxs-lookup"><span data-stu-id="0768b-143">Static resource references work best for the following circumstances:</span></span>

- <span data-ttu-id="0768b-144">アプリの設計で、そのほとんどのリソースがページまたはアプリケーション レベルのリソース ディクショナリに集中している。</span><span class="sxs-lookup"><span data-stu-id="0768b-144">Your app design concentrates most of its resources into page or application-level resource dictionaries.</span></span> <span data-ttu-id="0768b-145">静的リソース参照が、ページの再読み込みなどの実行時の動作に基づいて再評価されない。</span><span class="sxs-lookup"><span data-stu-id="0768b-145">Static resource references aren't reevaluated based on runtime behaviors, such as reloading a page.</span></span> <span data-ttu-id="0768b-146">そのため、リソースやアプリの設計上必要とされない大量の動的リソース参照を回避するという、パフォーマンス上の利点があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-146">So there can be some performance benefit to avoiding large numbers of dynamic resource references when they aren't necessary based on your resource and app design.</span></span>

- <span data-ttu-id="0768b-147"><xref:System.Windows.DependencyObject> にも <xref:System.Windows.Freezable> にもないプロパティの値を設定しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-147">You're setting the value of a property that isn't on a <xref:System.Windows.DependencyObject> or a <xref:System.Windows.Freezable>.</span></span>

- <span data-ttu-id="0768b-148">DLL にコンパイルされ、アプリの一部としてパッケージ化、またはアプリ間で共有されるリソース ディクショナリを作成しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-148">You're creating a resource dictionary that will be compiled into a DLL and packaged as part of the app or shared between apps.</span></span>

- <span data-ttu-id="0768b-149">カスタム コントロール用のテーマを作成していて、そのテーマ内で使用されるリソースを定義しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-149">You're creating a theme for a custom control and are defining resources that are used within the themes.</span></span> <span data-ttu-id="0768b-150">この場合は通常、動的リソース参照の検索動作は望ましくありません。代わりに、検索が予測可能になり、テーマに対して自己完結するように、静的リソース参照動作を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-150">For this case, you typically do not want the dynamic resource reference lookup behavior; you instead want the static resource reference behavior so that the lookup is predictable and self-contained to the theme.</span></span> <span data-ttu-id="0768b-151">動的リソース参照では、テーマ内の参照でも実行時までは未評価のままになります。</span><span class="sxs-lookup"><span data-stu-id="0768b-151">With a dynamic resource reference, even a reference within a theme is left unevaluated until run-time.</span></span> <span data-ttu-id="0768b-152">また、場合によっては、テーマが適用されるときに、何らかのローカル要素によって、テーマで参照が試みられているキーが再定義され、検索でテーマ自体より前にそのローカル要素が失敗します。</span><span class="sxs-lookup"><span data-stu-id="0768b-152">and there is a chance that when the theme is applied, some local element will redefine a key that your theme is trying to reference, and the local element will fall prior to the theme itself in the lookup.</span></span> <span data-ttu-id="0768b-153">これが起こると、テーマは想定どおりに動作しません。</span><span class="sxs-lookup"><span data-stu-id="0768b-153">If that happens, your theme will not behave as expected.</span></span>

- <span data-ttu-id="0768b-154">リソースを使用して、多数の依存関係プロパティを設定しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-154">You're using resources to set large numbers of dependency properties.</span></span> <span data-ttu-id="0768b-155">依存関係プロパティには、プロパティ システムによって有効になる有効値キャッシュがあります。そのため、読み込み時に評価できる依存関係プロパティに値を指定すると、依存関係プロパティは再評価される式を確認する必要がなく、最後の有効値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="0768b-155">Dependency properties have effective value caching as enabled by the property system, so if you provide a value for a dependency property that can be evaluated at load time, the dependency property doesn't have to check for a reevaluated expression and can return the last effective value.</span></span> <span data-ttu-id="0768b-156">この手法ではパフォーマンス上の利点が得られる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-156">This technique can be a performance benefit.</span></span>

- <span data-ttu-id="0768b-157">すべてのコンシューマー用の基礎リソースを変更する必要がある、または [x:Shared 属性](../../../xaml-services/xshared-attribute.md)を使用してコンシューマーごとに別個の書き込み可能インスタンスを保持する必要がある。</span><span class="sxs-lookup"><span data-stu-id="0768b-157">You want to change the underlying resource for all consumers, or you want to maintain separate writable instances for each consumer by using the [x:Shared Attribute](../../../xaml-services/xshared-attribute.md).</span></span>

### <a name="static-resource-lookup-behavior"></a><span data-ttu-id="0768b-158">静的リソースの検索動作</span><span class="sxs-lookup"><span data-stu-id="0768b-158">Static resource lookup behavior</span></span>

<span data-ttu-id="0768b-159">静的リソースがプロパティまたは要素によって参照されるときに自動的に行われる検索プロセスについて、下記で説明します。</span><span class="sxs-lookup"><span data-stu-id="0768b-159">The following describes the lookup process that automatically happens when a static resource is referenced by a property or element:</span></span>

01. <span data-ttu-id="0768b-160">検索プロセスでは、プロパティを設定する要素によって定義されたリソース ディクショナリ内で、要求されたキーが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-160">The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</span></span>

01. <span data-ttu-id="0768b-161">検索プロセスでは次に、親要素とそのリソース ディクショナリに向かって、論理ツリーが上方向に走査されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-161">The lookup process then traverses the logical tree upward to the parent element and its resource dictionary.</span></span> <span data-ttu-id="0768b-162">このプロセスは、ルート要素に到達するまで続けられます。</span><span class="sxs-lookup"><span data-stu-id="0768b-162">This process continues until the root element is reached.</span></span>

01. <span data-ttu-id="0768b-163">アプリ リソースが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-163">App resources are checked.</span></span> <span data-ttu-id="0768b-164">アプリ リソースとは、WPF アプリの <xref:System.Windows.Application> オブジェクトによって定義されたリソース ディクショナリ内のリソースのことです。</span><span class="sxs-lookup"><span data-stu-id="0768b-164">App resources are those resources within the resource dictionary that is defined by the <xref:System.Windows.Application> object for your WPF app.</span></span>

<span data-ttu-id="0768b-165">リソース ディクショナリ内からの静的リソース参照では、リソース参照の前に既に辞書的に定義されているリソースを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-165">Static resource references from within a resource dictionary must reference a resource that has already been defined lexically before the resource reference.</span></span> <span data-ttu-id="0768b-166">前方参照は、静的リソース参照では解決できません。</span><span class="sxs-lookup"><span data-stu-id="0768b-166">Forward references cannot be resolved by a static resource reference.</span></span> <span data-ttu-id="0768b-167">このため、リソースがそれぞれのリソース ディクショナリの先頭または先頭付近で定義されるように、リソース ディクショナリの構造を設計してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-167">For this reason, design your resource dictionary structure such that resources are defined at or near the beginning of each respective resource dictionary.</span></span>

<span data-ttu-id="0768b-168">静的リソース検索はテーマまたはシステム リソースにまで拡張できますが、この検索は、XAML ローダーによって要求が遅延されるという理由だけでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="0768b-168">Static resource lookup can extend into themes or into system resources, but this lookup is supported only because the XAML loader defers the request.</span></span> <span data-ttu-id="0768b-169">この遅延は、ページの読み込み時のランタイム テーマがアプリに適切に適用されるようにするために必要です。</span><span class="sxs-lookup"><span data-stu-id="0768b-169">The deferral is necessary so that the runtime theme at the time the page loads applies properly to the app.</span></span> <span data-ttu-id="0768b-170">ただし、テーマ内、またはシステム リソースとしてのみ存在することがわかっているキーに対する静的リソース参照はお勧めできません。このような参照は、テーマがユーザーによってリアルタイムで変更された場合に再評価されないためです。</span><span class="sxs-lookup"><span data-stu-id="0768b-170">However, static resource references to keys that are known to only exist in themes or as system resources aren't recommended, because such references aren't reevaluated if the theme is changed by the user in real time.</span></span> <span data-ttu-id="0768b-171">テーマまたはシステム リソースを要求するときは、動的リソース参照の方が信頼性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="0768b-171">A dynamic resource reference is more reliable when you request theme or system resources.</span></span> <span data-ttu-id="0768b-172">例外は、テーマ要素自体が別のリソースを要求する場合です。</span><span class="sxs-lookup"><span data-stu-id="0768b-172">The exception is when a theme element itself requests another resource.</span></span> <span data-ttu-id="0768b-173">これらの参照は、前述の理由で、静的リソース参照でなければなりません。</span><span class="sxs-lookup"><span data-stu-id="0768b-173">These references should be static resource references, for the reasons mentioned earlier.</span></span>

<span data-ttu-id="0768b-174">静的リソース参照が見つからない場合の例外動作にはさまざまなものがあります。</span><span class="sxs-lookup"><span data-stu-id="0768b-174">The exception behavior if a static resource reference isn't found varies.</span></span> <span data-ttu-id="0768b-175">リソースが遅延された場合、例外は実行時に発生します。</span><span class="sxs-lookup"><span data-stu-id="0768b-175">If the resource was deferred, then the exception occurs at runtime.</span></span> <span data-ttu-id="0768b-176">リソースが遅延されなかった場合、例外は読み込み時に発生します。</span><span class="sxs-lookup"><span data-stu-id="0768b-176">If the resource was not deferred, the exception occurs at load time.</span></span>

## <a name="dynamic-resources"></a><span data-ttu-id="0768b-177">動的リソース</span><span class="sxs-lookup"><span data-stu-id="0768b-177">Dynamic resources</span></span>

<span data-ttu-id="0768b-178">動的リソースは、次の場合に最適です。</span><span class="sxs-lookup"><span data-stu-id="0768b-178">Dynamic resources work best when:</span></span>

- <span data-ttu-id="0768b-179">リソース (システム リソースや、その他のユーザー設定可能なリソースを含む) の値が、実行時までわからない条件に依存している。</span><span class="sxs-lookup"><span data-stu-id="0768b-179">The value of the resource, including system resources, or resources that are otherwise user settable, depends on conditions that aren't known until runtime.</span></span> <span data-ttu-id="0768b-180">たとえば、<xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts>、または <xref:System.Windows.SystemParameters>によって公開されるシステム プロパティを参照するセッター値を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-180">For example, you can create setter values that refer to system properties as exposed by <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, or <xref:System.Windows.SystemParameters>.</span></span> <span data-ttu-id="0768b-181">これらの値は最終的にはユーザーとオペレーティング システムのランタイム環境から取得されるため、本当の意味で動的です。</span><span class="sxs-lookup"><span data-stu-id="0768b-181">These values are truly dynamic because they ultimately come from the runtime environment of the user and operating system.</span></span> <span data-ttu-id="0768b-182">また、変更される可能性のあるアプリケーションレベルのテーマを使用している場合もあります。この場合、ページレベルのリソースへのアクセスでもその変更を取り込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-182">You might also have application-level themes that can change, where page-level resource access must also capture the change.</span></span>

- <span data-ttu-id="0768b-183">カスタム コントロールのテーマ スタイルを作成または参照している。</span><span class="sxs-lookup"><span data-stu-id="0768b-183">You're creating or referencing theme styles for a custom control.</span></span>

- <span data-ttu-id="0768b-184">アプリの有効期間中に <xref:System.Windows.ResourceDictionary> の内容を調整するつもりである。</span><span class="sxs-lookup"><span data-stu-id="0768b-184">You intend to adjust the contents of a <xref:System.Windows.ResourceDictionary> during an app lifetime.</span></span>

- <span data-ttu-id="0768b-185">相互依存関係を含む複雑なリソース構造を使用していて、前方参照が必要になる可能性がある。</span><span class="sxs-lookup"><span data-stu-id="0768b-185">You have a complicated resource structure that has interdependencies, where a forward reference may be required.</span></span> <span data-ttu-id="0768b-186">前方参照は静的リソース参照ではサポートされません。ただし、動的リソース参照ではサポートされます。この理由は、リソースは実行時まで評価される必要がなく、前方参照が重要性の高い概念ではないためです。</span><span class="sxs-lookup"><span data-stu-id="0768b-186">Static resource references do not support forward references, but dynamic resource references do support them because the resource doesn't need to be evaluated until runtime, and forward references are therefore not a relevant concept.</span></span>

- <span data-ttu-id="0768b-187">コンパイルまたは作業セットの観点では大規模であるリソースを参照していて、そのリソースはページの読み込み時にすぐに使用されない可能性がある。</span><span class="sxs-lookup"><span data-stu-id="0768b-187">You're referencing a resource that is large from the perspective of a compile or working set, and the resource might not be used immediately when the page loads.</span></span> <span data-ttu-id="0768b-188">静的リソース参照は常に、ページの読み込み時に XAML から読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="0768b-188">Static resource references always load from XAML when the page loads.</span></span> <span data-ttu-id="0768b-189">しかし、動的リソース参照は、使用されるまで読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="0768b-189">However, a dynamic resource reference doesn't load until it's used.</span></span>

- <span data-ttu-id="0768b-190">セッター値がテーマやその他のユーザー設定に影響される他の値から取得される可能性のあるスタイルを作成しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-190">You're creating a style where setter values might come from other values that are influenced by themes or other user settings.</span></span>

- <span data-ttu-id="0768b-191">アプリの有効期間中に論理ツリー内で親が変更される可能性のある要素にリソースを適用しようとしている。</span><span class="sxs-lookup"><span data-stu-id="0768b-191">You're applying resources to elements that might be reparented in the logical tree during app lifetime.</span></span> <span data-ttu-id="0768b-192">親を変更するとリソース検索スコープも変更される可能性があるため、親が変更された要素のリソースが新しいスコープに基づいて再評価されるようにする場合は、常に動的リソース参照を使用してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-192">Changing the parent also potentially changes the resource lookup scope, so if you want the resource for a reparented element to be reevaluated based on the new scope, always use a dynamic resource reference.</span></span>

### <a name="dynamic-resource-lookup-behavior"></a><span data-ttu-id="0768b-193">動的リソースの検索動作</span><span class="sxs-lookup"><span data-stu-id="0768b-193">Dynamic resource lookup behavior</span></span>

<span data-ttu-id="0768b-194">動的リソース参照でのリソース検索動作は、<xref:System.Windows.FrameworkElement.FindResource%2A> または <xref:System.Windows.FrameworkElement.SetResourceReference%2A>を呼び出す場合のコード内での検索動作に似ています。</span><span class="sxs-lookup"><span data-stu-id="0768b-194">Resource lookup behavior for a dynamic resource reference parallels the lookup behavior in your code if you call <xref:System.Windows.FrameworkElement.FindResource%2A> or <xref:System.Windows.FrameworkElement.SetResourceReference%2A>:</span></span>

01. <span data-ttu-id="0768b-195">検索では、プロパティを設定する要素によって定義されたリソース ディクショナリ内で、要求されたキーが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-195">The lookup checks for the requested key within the resource dictionary defined by the element that sets the property:</span></span>

    - <span data-ttu-id="0768b-196">要素で <xref:System.Windows.FrameworkElement.Style%2A> プロパティが定義される場合、その要素の <xref:System.Windows.FrameworkElement.Style?displayProperty=fullName> ではその<xref:System.Windows.Style.Resources> ディクショナリが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-196">If the element defines a <xref:System.Windows.FrameworkElement.Style%2A> property, the <xref:System.Windows.FrameworkElement.Style?displayProperty=fullName> of the element has its <xref:System.Windows.Style.Resources> dictionary checked.</span></span>

    - <span data-ttu-id="0768b-197">要素で <xref:System.Windows.Controls.Control.Template%2A> プロパティが定義される場合、その要素の <xref:System.Windows.FrameworkTemplate.Resources?displayProperty=fullName> ディクショナリが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-197">If the element defines a <xref:System.Windows.Controls.Control.Template%2A> property, the <xref:System.Windows.FrameworkTemplate.Resources?displayProperty=fullName> dictionary of the element is checked.</span></span>

01. <span data-ttu-id="0768b-198">検索では、親要素とそのリソース ディクショナリに向かって、論理ツリーが上方向に走査されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-198">The lookup traverses the logical tree upward to the parent element and its resource dictionary.</span></span> <span data-ttu-id="0768b-199">このプロセスは、ルート要素に到達するまで続けられます。</span><span class="sxs-lookup"><span data-stu-id="0768b-199">This process continues until the root element is reached.</span></span>

01. <span data-ttu-id="0768b-200">アプリ リソースが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-200">App resources are checked.</span></span> <span data-ttu-id="0768b-201">アプリ リソースとは、WPF アプリの <xref:System.Windows.Application> オブジェクトによって定義されたリソース ディクショナリ内のリソースのことです。</span><span class="sxs-lookup"><span data-stu-id="0768b-201">App resources are those resources within the resource dictionary that are defined by the <xref:System.Windows.Application> object for your WPF app.</span></span>

01. <span data-ttu-id="0768b-202">テーマのリソース ディクショナリは、現在アクティブなテーマについて確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-202">The theme resource dictionary is checked for the currently active theme.</span></span> <span data-ttu-id="0768b-203">実行時にテーマが変更された場合、値は再評価されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-203">If the theme changes at runtime, the value is reevaluated.</span></span>

01. <span data-ttu-id="0768b-204">システム リソースが確認されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-204">System resources are checked.</span></span>

<span data-ttu-id="0768b-205">例外の動作 (存在する場合) にはさまざまなものがあります。</span><span class="sxs-lookup"><span data-stu-id="0768b-205">Exception behavior (if any) varies:</span></span>

- <span data-ttu-id="0768b-206">リソースが <xref:System.Windows.FrameworkElement.FindResource%2A> 呼び出しによって要求され、見つからなかった場合、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="0768b-206">If a resource was requested by a <xref:System.Windows.FrameworkElement.FindResource%2A> call and was not found, an exception is thrown.</span></span>

- <span data-ttu-id="0768b-207">リソースが <xref:System.Windows.FrameworkElement.TryFindResource%2A> 呼び出しによって要求され、見つからなかった場合、例外はスローされず、戻り値は `null` になります。</span><span class="sxs-lookup"><span data-stu-id="0768b-207">If a resource was requested by a <xref:System.Windows.FrameworkElement.TryFindResource%2A> call and was not found, no exception is thrown, and the returned value is `null`.</span></span> <span data-ttu-id="0768b-208">設定するプロパティで `null` が受け入れられない場合でも、設定対象の個々のプロパティに応じて、より深刻な例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-208">If the property being set doesn't accept `null`, then it's still possible that a deeper exception will be thrown, depending on the individual property being set.</span></span>

- <span data-ttu-id="0768b-209">リソースが XAML の動的リソース参照によって要求され、見つからなかった場合、その動作は一般的なプロパティ システムによって決まります。</span><span class="sxs-lookup"><span data-stu-id="0768b-209">If a resource was requested by a dynamic resource reference in XAML and was not found, then the behavior depends on the general property system.</span></span> <span data-ttu-id="0768b-210">一般的な動作は、リソースが存在するレベルでプロパティ設定操作が行われなかった場合と同様です。</span><span class="sxs-lookup"><span data-stu-id="0768b-210">The general behavior is as if no property setting operation occurred at the level where the resource exists.</span></span> <span data-ttu-id="0768b-211">たとえば、評価できなかったリソースを使用して個別のボタン要素の背景を設定しようとすると、値は設定されませんが、プロパティ システムの他の参加項目から値の優先順位で有効な値を取得できます。</span><span class="sxs-lookup"><span data-stu-id="0768b-211">For instance, if you attempt to set the background on an individual button element using a resource that could not be evaluated, then no value set results, but the effective value can still come from other participants in the property system and value precedence.</span></span> <span data-ttu-id="0768b-212">たとえば、背景値は、ローカルに定義されたボタン スタイルまたはテーマ スタイルから取得される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-212">For instance, the background value might still come from a locally defined button style or from the theme style.</span></span> <span data-ttu-id="0768b-213">テーマ スタイルによって定義されていないプロパティの場合、リソースの評価に失敗した後の有効な値は、プロパティ メタデータの既定値から取得される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-213">For properties that aren't defined by theme styles, the effective value after a failed resource evaluation might come from the default value in the property metadata.</span></span>

### <a name="restrictions"></a><span data-ttu-id="0768b-214">制約</span><span class="sxs-lookup"><span data-stu-id="0768b-214">Restrictions</span></span>

<span data-ttu-id="0768b-215">動的リソース参照には、注意が必要な制約がいくつか存在します。</span><span class="sxs-lookup"><span data-stu-id="0768b-215">Dynamic resource references have some notable restrictions.</span></span> <span data-ttu-id="0768b-216">次の条件のうち、少なくとも 1 つが満たされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-216">At least one of the following conditions must be true:</span></span>

- <span data-ttu-id="0768b-217">設定するプロパティは、<xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement> のプロパティでなければなりません。</span><span class="sxs-lookup"><span data-stu-id="0768b-217">The property being set must be a property on a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="0768b-218">そのプロパティは、<xref:System.Windows.DependencyProperty> によってサポートされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-218">That property must be backed by a <xref:System.Windows.DependencyProperty>.</span></span>

- <span data-ttu-id="0768b-219">参照が `StyleSetter` 内の値を対象としています。</span><span class="sxs-lookup"><span data-stu-id="0768b-219">The reference is for a value within a `StyleSetter`.</span></span>

- <span data-ttu-id="0768b-220">設定するプロパティは、<xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement> プロパティの値または <xref:System.Windows.Setter> 値として指定される、<xref:System.Windows.Freezable> のプロパティでなければなりません。</span><span class="sxs-lookup"><span data-stu-id="0768b-220">The property being set must be a property on a <xref:System.Windows.Freezable> that is provided as a value of either a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> property, or a <xref:System.Windows.Setter> value.</span></span>

<span data-ttu-id="0768b-221">設定するプロパティは <xref:System.Windows.DependencyProperty> または <xref:System.Windows.Freezable> プロパティでなければならないため、ほとんどのプロパティ変更が UI に反映される可能性があります。プロパティの変更 (動的リソース値の変更) はプロパティ システムによって確認されるためです。</span><span class="sxs-lookup"><span data-stu-id="0768b-221">Because the property being set must be a <xref:System.Windows.DependencyProperty> or <xref:System.Windows.Freezable> property, most property changes can propagate to the UI because a property change (the changed dynamic resource value) is acknowledged by the property system.</span></span> <span data-ttu-id="0768b-222">ほとんどのコントロールには、<xref:System.Windows.DependencyProperty> が変更され、そのプロパティがレイアウトに影響する可能性がある場合に、コントロールの別のレイアウトを強制的に適用するロジックが組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="0768b-222">Most controls include logic that will force another layout of a control if a <xref:System.Windows.DependencyProperty> changes and that property might affect layout.</span></span> <span data-ttu-id="0768b-223">ただし、[DynamicResource のマークアップ拡張機能](dynamicresource-markup-extension.md)を値として含むすべてのプロパティで、UI のリアルタイム更新が確実に行われるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="0768b-223">However, not all properties that have a [DynamicResource Markup Extension](dynamicresource-markup-extension.md) as their value are guaranteed to provide real time updates in the UI.</span></span> <span data-ttu-id="0768b-224">この機能は、プロパティに応じて、およびプロパティを所有する型に応じて、または場合によってはアプリの論理構造に応じて異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-224">That functionality still might vary depending on the property, as well as depending on the type that owns the property, or even the logical structure of your app.</span></span>

## <a name="styles-datatemplates-and-implicit-keys"></a><span data-ttu-id="0768b-225">スタイル、DataTemplates、暗黙的なキー</span><span class="sxs-lookup"><span data-stu-id="0768b-225">Styles, DataTemplates, and implicit keys</span></span>

<span data-ttu-id="0768b-226"><xref:System.Windows.ResourceDictionary> 内のすべての項目にキーが必要ですが、それは、すべてのリソースに明示的な `x:Key` が必要であることを意味するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="0768b-226">Although all items in a <xref:System.Windows.ResourceDictionary> must have a key, that doesn't mean that all resources must have an explicit `x:Key`.</span></span> <span data-ttu-id="0768b-227">リソースとして定義されている場合、いくつかのオブジェクトの型で暗黙的なキーがサポートされます。その場合、キーの値は、別のプロパティの値に関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="0768b-227">Several object types support an implicit key when defined as a resource, where the key value is tied to the value of another property.</span></span> <span data-ttu-id="0768b-228">この種類のキーが暗黙的なキーと呼ばれます。それに対し、`x:Key` 属性は明示的なキーです。</span><span class="sxs-lookup"><span data-stu-id="0768b-228">This type of key is known as an implicit key, whereas an `x:Key` attribute is an explicit key.</span></span> <span data-ttu-id="0768b-229">暗黙的なキーを上書きするには、明示的なキーを指定します。</span><span class="sxs-lookup"><span data-stu-id="0768b-229">You can overwrite any implicit key by specifying an explicit key.</span></span>

<span data-ttu-id="0768b-230">リソースの重要シナリオの 1 つに、<xref:System.Windows.Style> を定義する場合が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="0768b-230">One important scenario for resources is when you define a <xref:System.Windows.Style>.</span></span> <span data-ttu-id="0768b-231">事実、<xref:System.Windows.Style> はほとんどの場合、リソース ディクショナリ内のエントリとして定義されます。スタイルが本来、再利用を目的としているためです。</span><span class="sxs-lookup"><span data-stu-id="0768b-231">In fact, a <xref:System.Windows.Style> is almost always defined as an entry in a resource dictionary, because styles are inherently intended for reuse.</span></span> <span data-ttu-id="0768b-232">スタイルの詳細については、「[スタイルとテンプレート](../controls/styles-templates-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-232">For more information about styles, see [Styling and Templating](../controls/styles-templates-overview.md).</span></span>

<span data-ttu-id="0768b-233">コントロールのスタイルは、暗黙的なキーを使用して作成と参照の両方を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="0768b-233">Styles for controls can be both created with and referenced with an implicit key.</span></span> <span data-ttu-id="0768b-234">コントロールの既定の外観を定義するテーマ スタイルは、この暗黙的なキーに依存しています。</span><span class="sxs-lookup"><span data-stu-id="0768b-234">The theme styles that define the default appearance of a control rely on this implicit key.</span></span> <span data-ttu-id="0768b-235">それを要求する側の観点では、暗黙的なキーはコントロール自体の <xref:System.Type> です。</span><span class="sxs-lookup"><span data-stu-id="0768b-235">From the standpoint of requesting it, the implicit key is the <xref:System.Type> of the control itself.</span></span> <span data-ttu-id="0768b-236">リソースを定義する側の観点では、暗黙的なキーはスタイルの <xref:System.Windows.Style.TargetType%2A> です。</span><span class="sxs-lookup"><span data-stu-id="0768b-236">From the standpoint of defining the resources, the implicit key is the <xref:System.Windows.Style.TargetType%2A> of the style.</span></span> <span data-ttu-id="0768b-237">したがって、カスタム コントロールのテーマを作成する場合、または既存のテーマ スタイルと相互に作用するスタイルを作成する場合は、その <xref:System.Windows.Style> に対して [x:Key ディレクティブ](../../../xaml-services/xkey-directive.md)を指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0768b-237">Therefore, if you're creating themes for custom controls or creating styles that interact with existing theme styles, you do not need to specify an [x:Key Directive](../../../xaml-services/xkey-directive.md) for that <xref:System.Windows.Style>.</span></span> <span data-ttu-id="0768b-238">また、テーマ スタイルを使用する場合に、スタイルを指定する必要はいっさいありません。</span><span class="sxs-lookup"><span data-stu-id="0768b-238">And if you want to use the themed styles, you do not need to specify any style at all.</span></span> <span data-ttu-id="0768b-239">たとえば、<xref:System.Windows.Style> リソースにキーがないように見える場合でも、次のスタイル定義は機能します。</span><span class="sxs-lookup"><span data-stu-id="0768b-239">For instance, the following style definition works, even though the <xref:System.Windows.Style> resource doesn't appear to have a key:</span></span>

[!code-xaml[FEResourceSH_snip#ImplicitStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#implicitstyle)]

<span data-ttu-id="0768b-240">このスタイルには実際にはキー、つまり暗黙的なキー `typeof(System.Windows.Controls.Button)` があります。</span><span class="sxs-lookup"><span data-stu-id="0768b-240">That style really does have a key: the implicit key `typeof(System.Windows.Controls.Button)`.</span></span> <span data-ttu-id="0768b-241">マークアップでは、<xref:System.Windows.Style.TargetType%2A> を型名として直接指定して (または、必要に応じて [{x:Type...}](../../../xaml-services/xtype-markup-extension.md) を使用して)、</span><span class="sxs-lookup"><span data-stu-id="0768b-241">In markup, you can specify a <xref:System.Windows.Style.TargetType%2A> directly as the type name (or you can optionally use [{x:Type...}](../../../xaml-services/xtype-markup-extension.md)</span></span> <span data-ttu-id="0768b-242"><xref:System.Type> が返されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="0768b-242">to return a <xref:System.Type>.</span></span>

<span data-ttu-id="0768b-243">WPF によって使用される既定のテーマ スタイル メカニズムを通じて、そのスタイルは、ページに <xref:System.Windows.Controls.Button> のランタイム スタイルとして適用されます。これは、その <xref:System.Windows.Controls.Button> 自体で、スタイルに対するその <xref:System.Windows.FrameworkElement.Style%2A> プロパティまたは特定のリソース参照の指定が試みられない場合でも行われます。</span><span class="sxs-lookup"><span data-stu-id="0768b-243">Through the default theme style mechanisms used by WPF, that style is applied as the runtime style of a <xref:System.Windows.Controls.Button> on the page, even though the <xref:System.Windows.Controls.Button> itself doesn't attempt to specify its <xref:System.Windows.FrameworkElement.Style%2A> property or a specific resource reference to the style.</span></span> <span data-ttu-id="0768b-244">ページで定義されたスタイルは、テーマ ディクショナリ スタイルが持つキーと同じキーを使用して、検索シーケンス内でテーマ ディクショナリ スタイルより早く見つけられます。</span><span class="sxs-lookup"><span data-stu-id="0768b-244">Your style defined in the page is found earlier in the lookup sequence than the theme dictionary style, using the same key that the theme dictionary style has.</span></span> <span data-ttu-id="0768b-245">ページ内の任意の場所で `<Button>Hello</Button>` を指定するだけで、`Button` の <xref:System.Windows.Style.TargetType%2A> によって定義したスタイルがそのボタンに適用されます。</span><span class="sxs-lookup"><span data-stu-id="0768b-245">You could just specify `<Button>Hello</Button>` anywhere in the page, and the style you defined with <xref:System.Windows.Style.TargetType%2A> of `Button` would apply to that button.</span></span> <span data-ttu-id="0768b-246">必要であれば、マークアップを明確にするために、<xref:System.Windows.Style.TargetType%2A> と同じ型の値を持つスタイルに明示的にキーを付けることもできますが、これは任意です。</span><span class="sxs-lookup"><span data-stu-id="0768b-246">If you want, you can still explicitly key the style with the same type value as <xref:System.Windows.Style.TargetType%2A> for clarity in your markup, but that is optional.</span></span>

<span data-ttu-id="0768b-247"><xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> が `true` の場合、スタイルの暗黙的なキーはコントロールに適用されません。</span><span class="sxs-lookup"><span data-stu-id="0768b-247">Implicit keys for styles do not apply on a control if <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> is `true`.</span></span> <span data-ttu-id="0768b-248">(<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> は、コントロールのインスタンスで明示的に設定されるのではなく、コントロール クラスのネイティブ動作の一部として設定される場合があることにも注意してください。)また、派生クラスのシナリオで暗黙的なキーをサポートするには、コントロールで <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> がオーバーライドされる必要があります (WPF の一部として提供される既存のすべてのコントロールにこのオーバーライドが含まれています)。</span><span class="sxs-lookup"><span data-stu-id="0768b-248">(Also note that <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> might be set as part of native behavior for the control class, rather than explicitly on an instance of the control.) Also, in order to support implicit keys for derived class scenarios, the control must override <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> (all existing controls provided as part of WPF include this override).</span></span> <span data-ttu-id="0768b-249">スタイル、テーマ、コントロールの設計の詳細については、「[スタイルの設定が可能なコントロールを設計するためのガイドライン](../../../framework/wpf/controls/guidelines-for-designing-stylable-controls.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-249">For more information about styles, themes, and control design, see [Guidelines for Designing Stylable Controls](../../../framework/wpf/controls/guidelines-for-designing-stylable-controls.md).</span></span>

<span data-ttu-id="0768b-250"><xref:System.Windows.DataTemplate> には暗黙的なキーもあります。</span><span class="sxs-lookup"><span data-stu-id="0768b-250"><xref:System.Windows.DataTemplate> also has an implicit key.</span></span> <span data-ttu-id="0768b-251"><xref:System.Windows.DataTemplate> の暗黙的なキーは、<xref:System.Windows.DataTemplate.DataType%2A> プロパティ値です。</span><span class="sxs-lookup"><span data-stu-id="0768b-251">The implicit key for a <xref:System.Windows.DataTemplate> is the <xref:System.Windows.DataTemplate.DataType%2A> property value.</span></span> <span data-ttu-id="0768b-252"><xref:System.Windows.DataTemplate.DataType%2A> は、[{x:Type...}](../../../xaml-services/xtype-markup-extension.md) を使用して明示的に指定するのではなく、型の名前として指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="0768b-252"><xref:System.Windows.DataTemplate.DataType%2A> can also be specified as the name of the type rather than explicitly using [{x:Type...}](../../../xaml-services/xtype-markup-extension.md).</span></span> <span data-ttu-id="0768b-253">詳細については、「[データ テンプレートの概要](../../../framework/wpf/data/data-templating-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0768b-253">For details, see [Data Templating Overview](../../../framework/wpf/data/data-templating-overview.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="0768b-254">関連項目</span><span class="sxs-lookup"><span data-stu-id="0768b-254">See also</span></span>

- <xref:System.Windows.ResourceDictionary>
- [<span data-ttu-id="0768b-255">アプリケーション リソース</span><span class="sxs-lookup"><span data-stu-id="0768b-255">Application resources</span></span>](optimizing-performance-application-resources.md)
- [<span data-ttu-id="0768b-256">リソースとコード</span><span class="sxs-lookup"><span data-stu-id="0768b-256">Resources and code</span></span>](resources-and-code.md)
- [<span data-ttu-id="0768b-257">リソースを定義および参照する</span><span class="sxs-lookup"><span data-stu-id="0768b-257">Define and reference a resource</span></span>](how-to-define-and-reference-a-resource.md)
- [<span data-ttu-id="0768b-258">アプリケーション管理の概要</span><span class="sxs-lookup"><span data-stu-id="0768b-258">Application management overview</span></span>](../../../framework/wpf/app-development/application-management-overview.md)
- [<span data-ttu-id="0768b-259">x:Type マークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="0768b-259">x:Type markup extension</span></span>](../../../xaml-services/xtype-markup-extension.md)
- [<span data-ttu-id="0768b-260">StaticResource のマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="0768b-260">StaticResource markup extension</span></span>](staticresource-markup-extension.md)
- [<span data-ttu-id="0768b-261">DynamicResource のマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="0768b-261">DynamicResource markup extension</span></span>](dynamicresource-markup-extension.md)
