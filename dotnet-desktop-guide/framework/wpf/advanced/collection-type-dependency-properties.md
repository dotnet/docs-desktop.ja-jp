---
title: コレクション型依存関係プロパティ
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- properties [WPF], dependency
- properties [WPF], collection-type
- dependency properties [WPF]
- collection-type properties [WPF]
ms.assetid: 99f96a42-3ab7-4f64-a16b-2e10d654e97c
ms.openlocfilehash: 8da798b3d7254d10d8da7ca6df335f63e4890763
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96982360"
---
# <a name="collection-type-dependency-properties"></a><span data-ttu-id="a8e83-102">コレクション型依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="a8e83-102">Collection-Type Dependency Properties</span></span>
<span data-ttu-id="a8e83-103">ここでは、プロパティの型がコレクション型である場合に依存関係プロパティを実装する方法についての、ガイダンスと推奨されるパターンを示します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-103">This topic provides guidance and suggested patterns for how to implement a dependency property where the type of the property is a collection type.</span></span>  

<a name="implementing"></a>
## <a name="implementing-a-collection-type-dependency-property"></a><span data-ttu-id="a8e83-104">コレクション型依存関係プロパティの実装</span><span class="sxs-lookup"><span data-stu-id="a8e83-104">Implementing a Collection-Type Dependency Property</span></span>  
 <span data-ttu-id="a8e83-105">一般に、依存関係プロパティの場合、従う実装パターンは、CLR プロパティ ラッパーを定義するものです。この場合、そのプロパティは、フィールドや他のコンストラクトではなく <xref:System.Windows.DependencyProperty> 識別子によってサポートされます。</span><span class="sxs-lookup"><span data-stu-id="a8e83-105">For a dependency property in general, the implementation pattern that you follow is that you define a CLR property wrapper, where that property is backed by a <xref:System.Windows.DependencyProperty> identifier rather than a field or other construct.</span></span> <span data-ttu-id="a8e83-106">コレクション型プロパティを実装するときは、これと同じパターンに従います。</span><span class="sxs-lookup"><span data-stu-id="a8e83-106">You follow this same pattern when you implement a collection-type property.</span></span> <span data-ttu-id="a8e83-107">ただし、コレクションに含まれる型自体が <xref:System.Windows.DependencyObject> または <xref:System.Windows.Freezable> の派生クラスである場合は常に、コレクション型プロパティを使用することでパターンは複雑になります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-107">However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <xref:System.Windows.DependencyObject> or <xref:System.Windows.Freezable> derived class.</span></span>  
  
<a name="initializing"></a>
## <a name="initializing-the-collection-beyond-the-default-value"></a><span data-ttu-id="a8e83-108">既定値を上回るコレクションの初期化</span><span class="sxs-lookup"><span data-stu-id="a8e83-108">Initializing the Collection Beyond the Default Value</span></span>  
 <span data-ttu-id="a8e83-109">依存関係プロパティを作成するときは、初期フィールド値としてプロパティの既定値を指定しません。</span><span class="sxs-lookup"><span data-stu-id="a8e83-109">When you create a dependency property, you do not specify the property default value as the initial field value.</span></span> <span data-ttu-id="a8e83-110">代わりに、依存関係プロパティのメタデータを使用して既定値を指定します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-110">Instead, you specify the default value through the dependency property metadata.</span></span> <span data-ttu-id="a8e83-111">プロパティが参照型の場合、依存関係プロパティのメタデータで指定する既定値はインスタンスごとの既定値ではありません。その型のすべてのインスタンスに適用される既定値です。</span><span class="sxs-lookup"><span data-stu-id="a8e83-111">If your property is a reference type, the default value specified in dependency property metadata is not a default value per instance; instead it is a default value that applies to all instances of the type.</span></span> <span data-ttu-id="a8e83-112">したがって、コレクション プロパティ メタデータによって定義される単一の静的コレクションを、その型の新しく作成されるインスタンスの作業既定値として使用しないように注意してください。</span><span class="sxs-lookup"><span data-stu-id="a8e83-112">Therefore you must be careful to not use the singular static collection defined by the collection property metadata as the working default value for newly created instances of your type.</span></span> <span data-ttu-id="a8e83-113">代わりに、クラス コンストラクターのロジックの一部として、コレクションの値に一意 (インスタンス) のコレクションを意図的に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-113">Instead, you must make sure that you deliberately set the collection value to a unique (instance) collection as part of your class constructor logic.</span></span> <span data-ttu-id="a8e83-114">それ以外の場合は、意図しないシングルトン クラスを作成することになります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-114">Otherwise you will have created an unintentional singleton class.</span></span>  
  
 <span data-ttu-id="a8e83-115">例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-115">Consider the following example.</span></span> <span data-ttu-id="a8e83-116">この例は、クラス `Aquarium` の定義を示しています。これには、既定値の欠点があります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-116">The following section of the example shows the definition for a class `Aquarium`, which contains a flaw with the default value.</span></span> <span data-ttu-id="a8e83-117">このクラスで定義されているコレクション型依存関係プロパティ `AquariumObjects` は、<xref:System.Windows.FrameworkElement> 型の制約でジェネリック <xref:System.Collections.Generic.List%601> 型を使用します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-117">The class defines the collection type dependency property `AquariumObjects`, which uses the generic <xref:System.Collections.Generic.List%601> type with a <xref:System.Windows.FrameworkElement> type constraint.</span></span> <span data-ttu-id="a8e83-118">依存関係プロパティに対する <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> の呼び出しでは、メタデータによって、既定値が新しいジェネリック <xref:System.Collections.Generic.List%601> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="a8e83-118">In the <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> call for the dependency property, the metadata establishes the default value to be a new generic <xref:System.Collections.Generic.List%601>.</span></span>

> [!WARNING]
> <span data-ttu-id="a8e83-119">次のコードは正しく動作しません。</span><span class="sxs-lookup"><span data-stu-id="a8e83-119">The following code does not behave correctly.</span></span>

 [!code-csharp[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport2/CSharp/page.xaml.cs#collectionproblemdefinition)]
 [!code-vb[PropertiesOvwSupport2#CollectionProblemDefinition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport2/visualbasic/page.xaml.vb#collectionproblemdefinition)]  
  
 <span data-ttu-id="a8e83-120">ただし、コードをこのままにすると、単一のリストの既定値が `Aquarium` のすべてのインスタンスで共有されます。</span><span class="sxs-lookup"><span data-stu-id="a8e83-120">However, if you just left the code as shown, that single list default value is shared for all instances of `Aquarium`.</span></span> <span data-ttu-id="a8e83-121">次のテスト コードは、2 つの異なる `Aquarium` インスタンスをインスタンス化し、それぞれに単一の異なる `Fish` を追加する方法を示していますが、これを実行すると、想定外の結果になります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-121">If you ran the following test code, which is intended to show how you would instantiate two separate `Aquarium` instances and add a single different `Fish` to each of them, you would see a surprising result:</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemtestcode)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemTestCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemtestcode)]  
  
 <span data-ttu-id="a8e83-122">各コレクションのカウントが 1 になるのではなく、いずれのコレクションもカウントが 2 になります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-122">Instead of each collection having a count of one, each collection has a count of two!</span></span> <span data-ttu-id="a8e83-123">これは、各 `Aquarium` で `Fish` が既定値のコレクションに追加されますが、その起因となっているのがメタデータでの単一のコンストラクター呼び出しであり、したがって、すべてのインスタンス間で共有されるためです。</span><span class="sxs-lookup"><span data-stu-id="a8e83-123">This is because each `Aquarium` added its `Fish` to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances.</span></span> <span data-ttu-id="a8e83-124">これは望ましい状況ではありません。</span><span class="sxs-lookup"><span data-stu-id="a8e83-124">This situation is almost never what you want.</span></span>  
  
 <span data-ttu-id="a8e83-125">この問題を解決するには、クラス コンストラクターの呼び出しの一部として、コレクションの依存関係プロパティの値を一意のインスタンスにリセットする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-125">To correct this problem, you must reset the collection dependency property value to a unique instance, as part of the class constructor call.</span></span> <span data-ttu-id="a8e83-126">プロパティは読み取り専用の依存関係プロパティであるため、クラス内だけでアクセスできる <xref:System.Windows.DependencyPropertyKey> を使用し、<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> メソッドを使用して設定します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-126">Because the property is a read-only dependency property, you use the <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> method to set it, using the <xref:System.Windows.DependencyPropertyKey> that is only accessible within the class.</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemctor)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemCtor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemctor)]  
  
 <span data-ttu-id="a8e83-127">再びテスト コードを実行すると、結果は期待したものに近くなり、各 `Aquarium` が独自の一意のコレクションをサポートします。</span><span class="sxs-lookup"><span data-stu-id="a8e83-127">Now, if you ran that same test code again, you could see more expected results, where each `Aquarium` supported its own unique collection.</span></span>  
  
 <span data-ttu-id="a8e83-128">コレクション プロパティを読み取り/書き込みにすると、このパターンには若干のバリエーションが発生します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-128">There would be a slight variation on this pattern if you chose to have your collection property be read-write.</span></span> <span data-ttu-id="a8e83-129">この場合は、コンストラクターからパブリック set アクセサーを呼び出して初期化を行うことができ、パブリック <xref:System.Windows.DependencyProperty> 識別子を使用して、set ラッパー内で <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> のキーなしのシグネチャを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-129">In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> within your set wrapper, using a public <xref:System.Windows.DependencyProperty> identifier.</span></span>  
  
## <a name="reporting-binding-value-changes-from-collection-properties"></a><span data-ttu-id="a8e83-130">コレクション プロパティからのバインディング値変更の報告</span><span class="sxs-lookup"><span data-stu-id="a8e83-130">Reporting Binding Value Changes from Collection Properties</span></span>  
 <span data-ttu-id="a8e83-131">それ自体が依存関係プロパティであるコレクション プロパティは、変更をサブプロパティに自動的には報告しません。</span><span class="sxs-lookup"><span data-stu-id="a8e83-131">A collection property that is itself a dependency property does not automatically report changes to its subproperties.</span></span> <span data-ttu-id="a8e83-132">コレクションにバインディングを作成している場合は、これによってバインディングが変更を報告しないことがあり、一部のデータ バインディング シナリオが無効になります。</span><span class="sxs-lookup"><span data-stu-id="a8e83-132">If you are creating bindings into a collection, this can prevent the binding from reporting changes, thus invalidating some data binding scenarios.</span></span> <span data-ttu-id="a8e83-133">ただし、コレクション型として <xref:System.Windows.FreezableCollection%601> を使用している場合は、コレクションに含まれる要素に対するサブプロパティの変更は正しく報告され、バインディングは予期したとおりに動作します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-133">However, if you use the collection type <xref:System.Windows.FreezableCollection%601> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected.</span></span>  
  
 <span data-ttu-id="a8e83-134">依存関係オブジェクト コレクションでサブプロパティのバインディングを有効にするには、<xref:System.Windows.FreezableCollection%601> 型としてコレクション プロパティを作成し、そのコレクションの型制約を <xref:System.Windows.DependencyObject> 派生クラスに指定します。</span><span class="sxs-lookup"><span data-stu-id="a8e83-134">To enable subproperty binding in a dependency object collection, create the collection property as type <xref:System.Windows.FreezableCollection%601>, with a type constraint for that collection to any <xref:System.Windows.DependencyObject> derived class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a8e83-135">関連項目</span><span class="sxs-lookup"><span data-stu-id="a8e83-135">See also</span></span>

- <xref:System.Windows.FreezableCollection%601>
- [<span data-ttu-id="a8e83-136">WPF における XAML とカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="a8e83-136">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
- [<span data-ttu-id="a8e83-137">データ バインディングの概要</span><span class="sxs-lookup"><span data-stu-id="a8e83-137">Data Binding Overview</span></span>](/dotnet/desktop-wpf/data/data-binding-overview)
- [<span data-ttu-id="a8e83-138">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="a8e83-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="a8e83-139">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="a8e83-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="a8e83-140">依存関係プロパティのメタデータ</span><span class="sxs-lookup"><span data-stu-id="a8e83-140">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
