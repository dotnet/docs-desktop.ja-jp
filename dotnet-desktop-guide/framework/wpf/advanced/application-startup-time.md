---
title: アプリケーションの起動時間
ms.date: 03/30/2017
helpviewer_keywords:
- splash screen [WPF], startup time
- WPF [WPF], startup time
- startup time [WPF]
- application startup [WPF]
- performance [WPF], startup time
ms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96
ms.openlocfilehash: effcc40800ed12e26c2594a11c210cc926743778
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/09/2020
ms.locfileid: "96984019"
---
# <a name="application-startup-time"></a><span data-ttu-id="67eba-102">アプリケーションの起動時間</span><span class="sxs-lookup"><span data-stu-id="67eba-102">Application Startup Time</span></span>
<span data-ttu-id="67eba-103">WPF アプリケーションの起動に必要な時間には、かなりばらつきがあります。</span><span class="sxs-lookup"><span data-stu-id="67eba-103">The amount of time that is required for a WPF application to start can vary greatly.</span></span> <span data-ttu-id="67eba-104">このトピックでは、Windows Presentation Foundation (WPF) アプリケーションの認識される起動時間と実際の起動時間を短縮する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="67eba-104">This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.</span></span>  
  
## <a name="understanding-cold-startup-and-warm-startup"></a><span data-ttu-id="67eba-105">コールド スタートとウォーム スタートについて</span><span class="sxs-lookup"><span data-stu-id="67eba-105">Understanding Cold Startup and Warm Startup</span></span>  
 <span data-ttu-id="67eba-106">コールド スタートは、システムの再起動後にアプリケーションを初めて起動するとき、またはアプリケーションを起動して閉じた後、時間をおいて再び起動するときに発生します。</span><span class="sxs-lookup"><span data-stu-id="67eba-106">Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time.</span></span> <span data-ttu-id="67eba-107">アプリケーションが起動するときに、必要なページ (コード、静的データ、レジストリなど) が Windows メモリ マネージャーのスタンバイ リストに存在しない場合、ページ フォールトが発生します。</span><span class="sxs-lookup"><span data-stu-id="67eba-107">When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur.</span></span> <span data-ttu-id="67eba-108">そのページをメモリに読み込むには、ディスクにアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-108">Disk access is required to bring the pages into memory.</span></span>  
  
 <span data-ttu-id="67eba-109">ウォーム スタートは、主要な共通言語ランタイム (CLR) コンポーネント用のページのほとんどが、既にメモリに読み込まれているときに発生し、貴重なディスク アクセス タイムを節約できます。</span><span class="sxs-lookup"><span data-stu-id="67eba-109">Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time.</span></span> <span data-ttu-id="67eba-110">このため、マネージド アプリケーションを再度実行すると、初回よりも短い時間で起動します。</span><span class="sxs-lookup"><span data-stu-id="67eba-110">That is why a managed application starts faster when it runs a second time.</span></span>  
  
## <a name="implement-a-splash-screen"></a><span data-ttu-id="67eba-111">スプラッシュ スクリーンの実装</span><span class="sxs-lookup"><span data-stu-id="67eba-111">Implement a Splash Screen</span></span>  
 <span data-ttu-id="67eba-112">アプリケーションを起動してから最初の UI が表示されるまでに、どうしても多大な時間がかかる場合は、"*スプラッシュ スクリーン*" を使用して、認識される起動時間を最適化します。</span><span class="sxs-lookup"><span data-stu-id="67eba-112">In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*.</span></span> <span data-ttu-id="67eba-113">この方法により、ユーザーがアプリケーションを起動すると、すぐにイメージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="67eba-113">This approach displays an image almost immediately after the user starts the application.</span></span> <span data-ttu-id="67eba-114">アプリケーションが最初の UI を表示する準備が整うと、スプラッシュ スクリーンはフェード アウトします。</span><span class="sxs-lookup"><span data-stu-id="67eba-114">When the application is ready to display its first UI, the splash screen fades.</span></span> <span data-ttu-id="67eba-115">スプラッシュ スクリーンは、.NET Framework 3.5 SP1 以降、<xref:System.Windows.SplashScreen> クラスを使用して実装することができます。</span><span class="sxs-lookup"><span data-stu-id="67eba-115">Starting in the .NET Framework 3.5 SP1, you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen.</span></span> <span data-ttu-id="67eba-116">詳細については、[WPF アプリケーションへのスプラッシュ スクリーンの追加](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)に関するページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="67eba-116">For more information, see [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md).</span></span>  
  
 <span data-ttu-id="67eba-117">ネイティブな Win32 グラフィックスを使用して、独自のスプラッシュ スクリーンを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="67eba-117">You can also implement your own splash screen by using native Win32 graphics.</span></span> <span data-ttu-id="67eba-118">独自の実装は、<xref:System.Windows.Application.Run%2A> メソッドが呼び出される前に表示してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-118">Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called.</span></span>  
  
## <a name="analyze-the-startup-code"></a><span data-ttu-id="67eba-119">スタートアップ コードの分析</span><span class="sxs-lookup"><span data-stu-id="67eba-119">Analyze the Startup Code</span></span>  
 <span data-ttu-id="67eba-120">コールド スタートに時間がかかる理由を特定します。</span><span class="sxs-lookup"><span data-stu-id="67eba-120">Determine the reason for a slow cold startup.</span></span> <span data-ttu-id="67eba-121">ディスク I/O が原因である可能性がありますが、常にそうとは限りません。</span><span class="sxs-lookup"><span data-stu-id="67eba-121">Disk I/O may be responsible, but this is not always the case.</span></span> <span data-ttu-id="67eba-122">通常、ネットワーク、Web サービス、ディスクなどの外部リソースの使用は最小限に抑えてください。</span><span class="sxs-lookup"><span data-stu-id="67eba-122">In general, you should minimize the use of external resources, such as network, Web services, or disk.</span></span>  
  
 <span data-ttu-id="67eba-123">テストを始める前に、実行中のアプリケーションやサービスが、マネージド コードまたは WPF コードを使用していないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-123">Before you test, verify that no other running applications or services use managed code or WPF code.</span></span>  
  
 <span data-ttu-id="67eba-124">再起動の直後に WPF アプリケーションを起動し、表示されるまでの時間を計測します。</span><span class="sxs-lookup"><span data-stu-id="67eba-124">Start your WPF application immediately after a reboot, and determine how long it takes to display.</span></span> <span data-ttu-id="67eba-125">その後アプリケーションを何回か起動し (ウォーム スタート)、各回の起動時間が初回よりも短ければ、コールド スタートの問題の原因は I/O であると判断できます。</span><span class="sxs-lookup"><span data-stu-id="67eba-125">If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.</span></span>  
  
 <span data-ttu-id="67eba-126">アプリケーションのコールド スタートの問題に I/O が無関係である場合は、アプリケーションが長時間かかる初期化や計算を実行しているか、イベントの完了を待機しているか、起動時に大量の JIT コンパイルを必要としている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-126">If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup.</span></span> <span data-ttu-id="67eba-127">以下のセクションでは、こうした状況のいくつかについてさらに詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="67eba-127">The following sections describe some of these situations in more detail.</span></span>  
  
## <a name="optimize-module-loading"></a><span data-ttu-id="67eba-128">モジュールの読み込みの最適化</span><span class="sxs-lookup"><span data-stu-id="67eba-128">Optimize Module Loading</span></span>  
 <span data-ttu-id="67eba-129">プロセス エクスプローラー (Procexp.exe)、Tlist.exe などのツールを使用して、アプリケーションがどのモジュールを読み込むかを調べます。</span><span class="sxs-lookup"><span data-stu-id="67eba-129">Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads.</span></span> <span data-ttu-id="67eba-130">`Tlist <pid>` コマンドを実行すると、プロセスによって読み込まれるすべてのモジュールが表示されます。</span><span class="sxs-lookup"><span data-stu-id="67eba-130">The command `Tlist <pid>` shows all the modules that are loaded by a process.</span></span>  
  
 <span data-ttu-id="67eba-131">たとえば、Web に接続しないにもかかわらず System.Web.dll が読み込まれている場合は、アプリケーション内にこのアセンブリを参照するモジュールが含まれています。</span><span class="sxs-lookup"><span data-stu-id="67eba-131">For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly.</span></span> <span data-ttu-id="67eba-132">この参照が本当に必要かどうかを検討してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-132">Check to make sure that the reference is necessary.</span></span>  
  
 <span data-ttu-id="67eba-133">アプリケーションに複数のモジュールがある場合は、それをマージして単一のモジュールにします。</span><span class="sxs-lookup"><span data-stu-id="67eba-133">If your application has multiple modules, merge them into a single module.</span></span> <span data-ttu-id="67eba-134">この方法により、CLR によるアセンブリ読み込みのオーバーヘッドが減少します。</span><span class="sxs-lookup"><span data-stu-id="67eba-134">This approach requires less CLR assembly-loading overhead.</span></span> <span data-ttu-id="67eba-135">アセンブリ数が減少すると、CLR の管理対象となる状態も少なくなります。</span><span class="sxs-lookup"><span data-stu-id="67eba-135">Fewer assemblies also mean that the CLR maintains less state.</span></span>  
  
## <a name="defer-initialization-operations"></a><span data-ttu-id="67eba-136">初期化処理の延期</span><span class="sxs-lookup"><span data-stu-id="67eba-136">Defer Initialization Operations</span></span>  
 <span data-ttu-id="67eba-137">メイン アプリケーション ウィンドウが表示されるまで、初期化コードの実行を延期することを検討します。</span><span class="sxs-lookup"><span data-stu-id="67eba-137">Consider postponing initialization code until after the main application window is rendered.</span></span>  
  
 <span data-ttu-id="67eba-138">初期化はクラス コンストラクター内で実行される場合があり、初期化コードが他のクラスを参照していと、多数のクラス コンストラクターが次々に実行される可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-138">Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.</span></span>  
  
## <a name="avoid-application-configuration"></a><span data-ttu-id="67eba-139">アプリケーション構成の回避</span><span class="sxs-lookup"><span data-stu-id="67eba-139">Avoid Application Configuration</span></span>  
 <span data-ttu-id="67eba-140">アプリケーション構成を回避することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-140">Consider avoiding application configuration.</span></span> <span data-ttu-id="67eba-141">たとえば、アプリケーションの構成要件がシンプルで、起動時間の目標が非常に厳しい場合は、構成の代わりに、レジストリ エントリまたはシンプルな INI ファイルを使って起動時間を短縮できます。</span><span class="sxs-lookup"><span data-stu-id="67eba-141">For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.</span></span>  
  
## <a name="utilize-the-gac"></a><span data-ttu-id="67eba-142">GAC の活用</span><span class="sxs-lookup"><span data-stu-id="67eba-142">Utilize the GAC</span></span>  
 <span data-ttu-id="67eba-143">アセンブリがグローバル アセンブリ キャッシュ (GAC) にインストールされていない場合、厳密な名前付きアセンブリのハッシュ検証と NGen イメージ検証 (コンピューター上でそのアセンブリのネイティブ イメージを使用できる場合) が原因で遅延が発生します。</span><span class="sxs-lookup"><span data-stu-id="67eba-143">If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer.</span></span> <span data-ttu-id="67eba-144">厳密な名前の検証は、GAC にインストールされているアセンブリに対してはスキップされます。</span><span class="sxs-lookup"><span data-stu-id="67eba-144">Strong-name verification is skipped for all assemblies installed in the GAC.</span></span> <span data-ttu-id="67eba-145">詳細については、「[Gacutil.exe (グローバル アセンブリ キャッシュ ツール)](/dotnet/framework/tools/gacutil-exe-gac-tool)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-145">For more information, see [Gacutil.exe (Global Assembly Cache Tool)](/dotnet/framework/tools/gacutil-exe-gac-tool).</span></span>  
  
## <a name="use-ngenexe"></a><span data-ttu-id="67eba-146">Ngen.exe の使用</span><span class="sxs-lookup"><span data-stu-id="67eba-146">Use Ngen.exe</span></span>  
 <span data-ttu-id="67eba-147">アプリケーションでネイティブ イメージ ジェネレーター (Ngen.exe) を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-147">Consider using the Native Image Generator (Ngen.exe) on your application.</span></span> <span data-ttu-id="67eba-148">Ngen.exe を使用すると、CPU 消費は減少しますが、Ngen.exe によって生成されるネイティブ イメージの方が MSIL イメージよりも大きいことが多いため、ディスク アクセスが増えます。</span><span class="sxs-lookup"><span data-stu-id="67eba-148">Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.</span></span>  
  
 <span data-ttu-id="67eba-149">ウォーム スタートの起動時間を短縮するには、アプリケーションでは必ず Ngen exe を使用します。これにより、アプリケーション コードの JIT コンパイルにかかる CPU コストを回避できます。</span><span class="sxs-lookup"><span data-stu-id="67eba-149">To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.</span></span>  
  
 <span data-ttu-id="67eba-150">コールド スタートでも、Ngen.exe を使用すると有効なことがあります。</span><span class="sxs-lookup"><span data-stu-id="67eba-150">In some cold startup scenarios, using Ngen.exe can also be helpful.</span></span> <span data-ttu-id="67eba-151">これは、JIT コンパイラ (mscorjit.dll) を読み込む必要がないためです。</span><span class="sxs-lookup"><span data-stu-id="67eba-151">This is because the JIT compiler (mscorjit.dll) does not have to be loaded.</span></span>  
  
 <span data-ttu-id="67eba-152">NGen と JIT モジュールを併用すると、最悪の影響がもたらされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-152">Having both Ngen and JIT modules can have the worst effect.</span></span> <span data-ttu-id="67eba-153">mscorjit.dll を読み込む必要があるほか、JIT コンパイラは、アプリケーション コードを処理するとき、アセンブリのメタデータを読み込む際に NGen イメージ内の多数のページにアクセスする必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="67eba-153">This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.</span></span>  
  
### <a name="ngen-and-clickonce"></a><span data-ttu-id="67eba-154">NGen と ClickOnce</span><span class="sxs-lookup"><span data-stu-id="67eba-154">Ngen and ClickOnce</span></span>  
 <span data-ttu-id="67eba-155">アプリケーションの配置方法が、読み込み時間に影響することもあります。</span><span class="sxs-lookup"><span data-stu-id="67eba-155">The way you plan to deploy your application can also make a difference in load time.</span></span> <span data-ttu-id="67eba-156">ClickOnce によるアプリケーションのデプロイでは、NGen がサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="67eba-156">ClickOnce application deployment does not support Ngen.</span></span> <span data-ttu-id="67eba-157">アプリケーションで Ngen.exe を使用する場合は、Windows インストーラーなど、他の配置機構を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-157">If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.</span></span>  
  
 <span data-ttu-id="67eba-158">詳細については、「[Ngen.exe (ネイティブ イメージ ジェネレーター)](/dotnet/framework/tools/ngen-exe-native-image-generator)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-158">For more information, see [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator).</span></span>  
  
### <a name="rebasing-and-dll-address-collisions"></a><span data-ttu-id="67eba-159">ベース変更と DLL アドレスの競合</span><span class="sxs-lookup"><span data-stu-id="67eba-159">Rebasing and DLL Address Collisions</span></span>  
 <span data-ttu-id="67eba-160">Ngen.exe を使用する場合は、ネイティブ イメージがメモリに読み込まれる際にベース変更が発生する可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-160">If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory.</span></span> <span data-ttu-id="67eba-161">希望のベース アドレスのアドレス範囲が既に割り当て済みであることが原因で、そのベース アドレスに DLL を読み込めない場合、Windows ローダーは、その DLL を別のアドレスに読み込みますが、これには時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="67eba-161">If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.</span></span>  
  
 <span data-ttu-id="67eba-162">仮想アドレス ダンプ (Vadump.exe) ツールを使用すると、すべてのページがプライベートであるモジュールが存在するかどうかを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="67eba-162">You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private.</span></span> <span data-ttu-id="67eba-163">存在する場合、そのモジュールは、別のアドレスにベース変更されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-163">If this is the case, the module may have been rebased to a different address.</span></span> <span data-ttu-id="67eba-164">したがって、そのページは共有できません。</span><span class="sxs-lookup"><span data-stu-id="67eba-164">Therefore, its pages cannot be shared.</span></span>  
  
 <span data-ttu-id="67eba-165">ベース アドレスを設定する方法の詳細については、「[Ngen.exe (ネイティブ イメージ ジェネレーター)](/dotnet/framework/tools/ngen-exe-native-image-generator)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-165">For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator).</span></span>  
  
## <a name="optimize-authenticode"></a><span data-ttu-id="67eba-166">Authenticode の最適化</span><span class="sxs-lookup"><span data-stu-id="67eba-166">Optimize Authenticode</span></span>  
 <span data-ttu-id="67eba-167">Authenticode 検証によって起動時間は長くなります。</span><span class="sxs-lookup"><span data-stu-id="67eba-167">Authenticode verification adds to the startup time.</span></span> <span data-ttu-id="67eba-168">Authenticode 署名があるアセンブリは、証明機関 (CA: Certification Authority) を使用して検証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-168">Authenticode-signed assemblies have to be verified with the certification authority (CA).</span></span> <span data-ttu-id="67eba-169">この検証では、最新の証明書失効リストをダウンロードするためにネットワークに複数回接続する必要があるので、時間がかかる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-169">This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists.</span></span> <span data-ttu-id="67eba-170">また、信頼できるルートへのパスに、有効な証明書すべてが存在することも確認します。</span><span class="sxs-lookup"><span data-stu-id="67eba-170">It also makes sure that there is a full chain of valid certificates on the path to a trusted root.</span></span> <span data-ttu-id="67eba-171">これにより、アセンブリの読み込み中に、数秒間の遅延が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-171">This can translate to several seconds of delay while the assembly is being loaded.</span></span>  
  
 <span data-ttu-id="67eba-172">CA 証明書をクライアント コンピューターにインストールするか、可能な場合は Authenticode の使用を避けることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-172">Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible.</span></span> <span data-ttu-id="67eba-173">アプリケーションが発行者の証拠を必要としないことがわかっている場合は、署名を検証する手間をかける必要はありません。</span><span class="sxs-lookup"><span data-stu-id="67eba-173">If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.</span></span>  
  
 <span data-ttu-id="67eba-174">.NET Framework 3.5 以降、Authenticode 検証のバイパスを可能にする構成オプションが用意されています。</span><span class="sxs-lookup"><span data-stu-id="67eba-174">Starting in .NET Framework 3.5, there is a configuration option that allows the Authenticode verification to be bypassed.</span></span> <span data-ttu-id="67eba-175">これを行うには、次の設定を app.exe.config ファイルに追加します。</span><span class="sxs-lookup"><span data-stu-id="67eba-175">To do this, add the following setting to the app.exe.config file:</span></span>  
  
```xml  
<configuration>  
    <runtime>  
        <generatePublisherEvidence enabled="false"/>
    </runtime>  
</configuration>  
```  
  
 <span data-ttu-id="67eba-176">詳細については、[\<generatePublisherEvidence> 要素](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-176">For more information, see [\<generatePublisherEvidence> Element](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element).</span></span>  
  
## <a name="compare-performance-on-windows-vista"></a><span data-ttu-id="67eba-177">Windows Vista でのパフォーマンスの比較</span><span class="sxs-lookup"><span data-stu-id="67eba-177">Compare Performance on Windows Vista</span></span>  
 <span data-ttu-id="67eba-178">Windows Vista のメモリ マネージャーには、SuperFetch というテクノロジが組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="67eba-178">The memory manager in Windows Vista has a technology called SuperFetch.</span></span> <span data-ttu-id="67eba-179">SuperFetch は、一定期間内のメモリ使用パターンを分析して、そのユーザーに適したメモリの内容を判断します。</span><span class="sxs-lookup"><span data-stu-id="67eba-179">SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user.</span></span> <span data-ttu-id="67eba-180">そして、その内容が維持されるよう継続的に動作します。</span><span class="sxs-lookup"><span data-stu-id="67eba-180">It works continuously to maintain that content at all times.</span></span>  
  
 <span data-ttu-id="67eba-181">これは、Windows XP で使用されているプリフェッチ手法とは異なります。プリフェッチでは、使用パターンを分析せずに、データをメモリにプリロードします。</span><span class="sxs-lookup"><span data-stu-id="67eba-181">This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns.</span></span> <span data-ttu-id="67eba-182">ユーザーが WPF アプリケーションを Windows Vista で頻繁に使用すると、アプリケーションのコールド スタートの起動時間は次第に短くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-182">Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.</span></span>  
  
## <a name="use-appdomains-efficiently"></a><span data-ttu-id="67eba-183">AppDomains の効率的な使用</span><span class="sxs-lookup"><span data-stu-id="67eba-183">Use AppDomains Efficiently</span></span>  
 <span data-ttu-id="67eba-184">可能な場合はアセンブリをドメイン中立コード領域に読み込み、アプリケーションで作成されるすべての AppDomains でネイティブ イメージが使用されるようにします (ネイティブ イメージが存在する場合)。</span><span class="sxs-lookup"><span data-stu-id="67eba-184">If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.</span></span>  
  
 <span data-ttu-id="67eba-185">パフォーマンスを最大限に高めるには、ドメイン間呼び出しを減らしてドメイン間の通信を効率化します。</span><span class="sxs-lookup"><span data-stu-id="67eba-185">For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls.</span></span> <span data-ttu-id="67eba-186">可能な場合は、引数のない呼び出し、または引数がプリミティブ型である呼び出しを使用します。</span><span class="sxs-lookup"><span data-stu-id="67eba-186">When possible, use calls without arguments or with primitive type arguments.</span></span>  
  
## <a name="use-the-neutralresourceslanguage-attribute"></a><span data-ttu-id="67eba-187">NeutralResourcesLanguage 属性の使用</span><span class="sxs-lookup"><span data-stu-id="67eba-187">Use the NeutralResourcesLanguage Attribute</span></span>  
 <span data-ttu-id="67eba-188"><xref:System.Resources.NeutralResourcesLanguageAttribute> を使用して、<xref:System.Resources.ResourceManager> のニュートラル カルチャを指定します。</span><span class="sxs-lookup"><span data-stu-id="67eba-188">Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="67eba-189">この方法を使用すると、アセンブリのルックアップの失敗が回避されます。</span><span class="sxs-lookup"><span data-stu-id="67eba-189">This approach avoids unsuccessful assembly lookups.</span></span>  
  
## <a name="use-the-binaryformatter-class-for-serialization"></a><span data-ttu-id="67eba-190">シリアル化での BinaryFormatter クラスの使用</span><span class="sxs-lookup"><span data-stu-id="67eba-190">Use the BinaryFormatter Class for Serialization</span></span>  
 <span data-ttu-id="67eba-191">シリアル化を使用する必要がある場合は、<xref:System.Xml.Serialization.XmlSerializer> クラスの代わりに <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="67eba-191">If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="67eba-192"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> クラスは、mscorlib.dll アセンブリの基本クラス ライブラリ (BCL) に実装されます。</span><span class="sxs-lookup"><span data-stu-id="67eba-192">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly.</span></span> <span data-ttu-id="67eba-193"><xref:System.Xml.Serialization.XmlSerializer> は System.Xml.dll アセンブリに実装されますが、これは、読み込まれる追加 DLL である場合があります。</span><span class="sxs-lookup"><span data-stu-id="67eba-193">The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.</span></span>  
  
 <span data-ttu-id="67eba-194"><xref:System.Xml.Serialization.XmlSerializer> クラスを使用する必要がある場合は、シリアル化アセンブリを事前に生成すると、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="67eba-194">If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly.</span></span>  
  
## <a name="configure-clickonce-to-check-for-updates-after-startup"></a><span data-ttu-id="67eba-195">起動後に更新プログラムをチェックする ClickOnce の構成</span><span class="sxs-lookup"><span data-stu-id="67eba-195">Configure ClickOnce to Check for Updates After Startup</span></span>  
 <span data-ttu-id="67eba-196">アプリケーションで ClickOnce を使用する場合は、アプリケーションの起動後にデプロイ サイトの更新プログラムをチェックするように ClickOnce を構成することで、ネットワーク アクセスを回避します。</span><span class="sxs-lookup"><span data-stu-id="67eba-196">If your application uses ClickOnce, avoid network access on startup by configuring ClickOnce to check the deployment site for updates after the application starts.</span></span>  
  
 <span data-ttu-id="67eba-197">XAML ブラウザー アプリケーション (XBAP) モデルを使用する場合、ClickOnce は、XBAP が既に ClickOnce キャッシュに存在する場合でも、デプロイ サイトの更新プログラムのチェックが行われることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-197">If you use the XAML browser application (XBAP) model, keep in mind that ClickOnce checks the deployment site for updates even if the XBAP is already in the ClickOnce cache.</span></span> <span data-ttu-id="67eba-198">詳細については、「 [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-198">For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment).</span></span>  
  
## <a name="configure-the-presentationfontcache-service-to-start-automatically"></a><span data-ttu-id="67eba-199">PresentationFontCache サービスの自動起動の構成</span><span class="sxs-lookup"><span data-stu-id="67eba-199">Configure the PresentationFontCache Service to Start Automatically</span></span>  
 <span data-ttu-id="67eba-200">再起動後に最初に実行される WPF アプリケーションは PresentationFontCache サービスです。</span><span class="sxs-lookup"><span data-stu-id="67eba-200">The first WPF application to run after a reboot is the PresentationFontCache service.</span></span> <span data-ttu-id="67eba-201">このサービスは、システム フォントをキャッシュし、フォント アクセスを高速化して、パフォーマンス全体を向上させます。</span><span class="sxs-lookup"><span data-stu-id="67eba-201">The service caches the system fonts, improves font access, and improves overall performance.</span></span> <span data-ttu-id="67eba-202">このサービスの起動にはオーバーヘッドが伴うため、一部の制御された環境では、システムの再起動時にこのサービスを自動起動するように構成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="67eba-202">There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.</span></span>  
  
## <a name="set-data-binding-programmatically"></a><span data-ttu-id="67eba-203">データ バインディングのプログラムによる設定</span><span class="sxs-lookup"><span data-stu-id="67eba-203">Set Data Binding Programmatically</span></span>  
 <span data-ttu-id="67eba-204">XAML を使用してメイン ウィンドウの <xref:System.Windows.FrameworkElement.DataContext%2A> を宣言によって設定するのではなく、<xref:System.Windows.Application.OnActivated%2A> メソッドでプログラムによって設定することを検討します。</span><span class="sxs-lookup"><span data-stu-id="67eba-204">Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="67eba-205">関連項目</span><span class="sxs-lookup"><span data-stu-id="67eba-205">See also</span></span>

- <xref:System.Windows.SplashScreen>
- <xref:System.AppDomain>
- <xref:System.Resources.NeutralResourcesLanguageAttribute>
- <xref:System.Resources.ResourceManager>
- [<span data-ttu-id="67eba-206">スプラッシュ スクリーンを WPF アプリケーションに追加する</span><span class="sxs-lookup"><span data-stu-id="67eba-206">Add a Splash Screen to a WPF Application</span></span>](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)
- [<span data-ttu-id="67eba-207">Ngen.exe (ネイティブ イメージ ジェネレーター)</span><span class="sxs-lookup"><span data-stu-id="67eba-207">Ngen.exe (Native Image Generator)</span></span>](/dotnet/framework/tools/ngen-exe-native-image-generator)
- [<span data-ttu-id="67eba-208">\<generatePublisherEvidence> 要素</span><span class="sxs-lookup"><span data-stu-id="67eba-208">\<generatePublisherEvidence> Element</span></span>](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element)
